"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[1789],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(n),p=r,m=h["".concat(l,".").concat(p)]||h[p]||d[p]||o;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(7294),r=n(6010);const o="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o,i),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>p});var a=n(7462),r=n(7294),o=n(6010),i=n(2389),s=n(7392),l=n(7094),c=n(2466);const u="tabList__CuJ",d="tabItem_LNqP";function h(e){var t;const{lazy:n,block:i,defaultValue:h,values:p,groupId:m,className:f}=e,g=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=p??g.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),v=(0,s.l)(b,((e,t)=>e.value===t.value));if(v.length>0)throw new Error(`Docusaurus error: Duplicate values "${v.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const y=null===h?h:h??(null==(t=g.find((e=>e.props.default)))?void 0:t.props.value)??g[0].props.value;if(null!==y&&!b.some((e=>e.value===y)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${y}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:w}=(0,l.U)(),[T,N]=(0,r.useState)(y),x=[],{blockElementScrollPositionUntilNextRender:P}=(0,c.o5)();if(null!=m){const e=k[m];null!=e&&e!==T&&b.some((t=>t.value===e))&&N(e)}const q=e=>{const t=e.currentTarget,n=x.indexOf(t),a=b[n].value;a!==T&&(P(t),N(a),null!=m&&w(m,String(a)))},C=e=>{var t;let n=null;switch(e.key){case"Enter":q(e);break;case"ArrowRight":{const t=x.indexOf(e.currentTarget)+1;n=x[t]??x[0];break}case"ArrowLeft":{const t=x.indexOf(e.currentTarget)-1;n=x[t]??x[x.length-1];break}}null==(t=n)||t.focus()};return r.createElement("div",{className:(0,o.Z)("tabs-container",u)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":i},f)},b.map((e=>{let{value:t,label:n,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:e=>x.push(e),onKeyDown:C,onClick:q},i,{className:(0,o.Z)("tabs__item",d,null==i?void 0:i.className,{"tabs__item--active":T===t})}),n??t)}))),n?(0,r.cloneElement)(g.filter((e=>e.props.value===T))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==T})))))}function p(e){const t=(0,i.Z)();return r.createElement(h,(0,a.Z)({key:String(t)},e))}},7967:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var a=n(7462),r=(n(7294),n(3905)),o=n(5488),i=n(5162);const s={title:"fetch data",sidebar_position:30},l=void 0,c={unversionedId:"request-timing/use-fetcher",id:"request-timing/use-fetcher",title:"fetch data",description:"When you have the following needs:",source:"@site/docs/04-request-timing/03-use-fetcher.md",sourceDirName:"04-request-timing",slug:"/request-timing/use-fetcher",permalink:"/request-timing/use-fetcher",draft:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/04-request-timing/03-use-fetcher.md",tags:[],version:"current",sidebarPosition:30,frontMatter:{title:"fetch data",sidebar_position:30},sidebar:"tutorialSidebar",previous:{title:"state change request",permalink:"/request-timing/use-watcher"},next:{title:"Response data management",permalink:"/category/response-data-management"}},u={},d=[{value:"Update views across modules/components",id:"update-views-across-modulescomponents",level:2},{value:"preload data",id:"preload-data",level:2}],h={toc:d};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When you have the following needs:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Preload the data that will be used in the subsequent process and store it in the cache, so that users no longer wait for the process of data loading;"),(0,r.kt)("li",{parentName:"ol"},"It is convenient to update data across pages (similar to the global state). For example, after modifying an item in the todo list, re-pull the latest data, and the interface will be refreshed after the response.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"useFetcher")," is a hook used to implement the above scenarios. The response data obtained through it cannot be directly received, but the data pulled through it will update the corresponding state in addition to updating the cache, thereby re-rendering the view."),(0,r.kt)("p",null,"You can use it to pre-fetch data and save it to the cache, or gracefully update state across components, such as modifying an item in the todo list and re-pulling the latest data, and the interface will be refreshed after the response"),(0,r.kt)("p",null,"Compared with ",(0,r.kt)("inlineCode",{parentName:"p"},"useRequest")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"useWatcher"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"useFetcher")," does not return ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," field, ",(0,r.kt)("inlineCode",{parentName:"p"},"loading")," is renamed ",(0,r.kt)("inlineCode",{parentName:"p"},"fetching"),", and there is no ",(0,r.kt)("inlineCode",{parentName:"p"},"send")," function, but there is a ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch")," function, which can be reused The fetch function pulls data from different interfaces. At this time, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"fetching")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"error")," states to render the view uniformly, so as to achieve the purpose of unified processing."),(0,r.kt)("h2",{id:"update-views-across-modulescomponents"},"Update views across modules/components"),(0,r.kt)("p",null,"Next, let's modify a todo data, and re-pull the latest todo list data to update the view."),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<template>\n  \x3c!-- Render a unified pull state. --\x3e\n  <div v-if=\"fetching\">{{ Fetching data in the background... }}</div>\n\n  \x3c!-- ... --\x3e\n  <button @click=\"handleSubmit\">Modify todo item</button>\n</template>\n\n<script setup>\n  const getTodoList = currentPage => {\n    return alovaInstance.Get('/tood/list', {\n      // Note: The name attribute is set here to filter out the required Method instance when the Method instance cannot be specified directly\n      // See the subsequent \"Method instance matcher\" chapter for details\n      name: 'todoList',\n      params: {\n        currentPage,\n        pageSize: 10\n      }\n    });\n  };\n\n  const {\n    // The fetching attribute is the same as loading, true when a pull request is sent, and false after the request is complete\n    fetching,\n    error,\n    onSuccess,\n    onError,\n    onComplete,\n\n    // Only after calling fetch will the request to pull data be sent. You can repeatedly call fetch multiple times to pull data from different interfaces.\n    fetch\n  } = useFetcher();\n\n  // Trigger data pull in event\n  const handleSubmit = () => {\n    // todo item modification...\n\n    // Start pulling the updated data\n    // Case 1: When you clearly know to pull the first page of todoList data, pass in a Method instance\n    fetch(getTodoList(1));\n\n    // Case 2: When you only know to pull the data of the last request of the todoList, filter by the Method instance matcher\n    fetch({\n      name: 'todoList',\n      filter: (method, index, ary) => {\n        // Return true to specify the Method instance to be pulled\n        return index === ary.length - 1;\n      }\n    });\n  };\n<\/script>\n"))),(0,r.kt)(i.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"const getTodoList = currentPage => {\nreturn alovaInstance.Get('/tood/list', {\n// Note: The name attribute is set here to filter out the required Method instance when the Method instance cannot be specified directly\n// See the subsequent \"Method instance matcher\" chapter for details\nname: 'todoList',\nparams: {\ncurrentPage,\npageSize: 10\n}\n});\n};\n\nconst App = () => {\nconst {\n// The fetching attribute is the same as loading, true when a pull request is sent, and false after the request is complete\nfetching,\nerror,\nonSuccess,\nonError,\nonComplete,\n\n// Only after calling fetch will the request to pull data be sent. You can repeatedly call fetch multiple times to pull data from different interfaces.\nfetch\n} = useFetcher();\n\n// Trigger data pull in event\nconst handleSubmit = () => {\n// Assuming you have finished modifying the todo item...\n\n// Start pulling the updated data\n// Case 1: When you clearly know to pull the first page of todoList data, pass in a Method instance\nfetch(getTodoList(1));\n\n// Case 2: When you only know to pull the data of the last request of the todoList, filter by the Method instance matcher\nfetch({\nname: 'todoList',\nfilter: (method, index, ary) => {\n// Return true to specify the Method instance to be pulled\nreturn index === ary.length - 1;\n}\n});\n};\n\nreturn (\n{/* Render unified pull state */}\n{ fetching ? <div>{{ Fetching data in the background... }}</div> : null }\n{/* ... */}\n<button onClick={handleSubmit}>Modify todo item</button>\n);\n};\n"))),(0,r.kt)(i.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<script>\n  const getTodoList = currentPage => {\n    return alovaInstance.Get('/tood/list', {\n      // Note: The name attribute is set here to filter out the required Method instance when the Method instance cannot be specified directly\n      // See the subsequent \"Method instance matcher\" chapter for details\n      name: 'todoList',\n      params: {\n        currentPage,\n        pageSize: 10\n      }\n    });\n  };\n\n  const {\n    // The fetching attribute is the same as loading, true when a pull request is sent, and false after the request is complete\n    fetching,\n    error,\n    onSuccess,\n    onError,\n    onComplete,\n\n    // Only after calling fetch will the request to pull data be sent. You can repeatedly call fetch multiple times to pull data from different interfaces.\n    fetch\n  } = useFetcher();\n\n  // Trigger data pull in event\n  const handleSubmit = () => {\n    // Assuming you have finished modifying the todo item...\n\n    // Start pulling the updated data\n    // Case 1: When you clearly know to pull the first page of todoList data, pass in a Method instance\n    fetch(getTodoList(1));\n\n    // Case 2: When you only know to pull the data of the last request of the todoList, filter by the Method instance matcher\n    fetch({\n      name: 'todoList',\n      filter: (method, index, ary) => {\n        // Return true to specify the Method instance to be pulled\n        return index === ary.length - 1;\n      }\n    });\n  };\n<\/script>\n\n\x3c!-- Render unified pull state --\x3e\n{#if $fetching}\n<div>{{ Pulling data in the background... }}</div>\n{/if}\n\x3c!-- ... --\x3e\n<button on:click=\"{handleSubmit}\">Modify todo item</button>\n")))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more usage of ",(0,r.kt)("inlineCode",{parentName:"p"},"Method")," instance matcher, see ",(0,r.kt)("a",{parentName:"p",href:"../next-step/method-instance-matcher"},"Method instance matcher"))),(0,r.kt)("h2",{id:"preload-data"},"preload data"),(0,r.kt)("p",null,"The following implements the preloading function of the next page data in the todo list paging scenario."),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<template>\n  \x3c!-- ... --\x3e\n</template>\n\n<script setup>\n  // method instance creation function\n  const getTodoList = currentPage => {\n    return alovaInstance.Get('/tood/list', {\n      params: {\n        currentPage,\n        pageSize: 10\n      }\n    });\n  };\n\n  const { fetch } = useFetcher();\n\n  const currentPage = ref(1);\n  const { data, onSuccess } = useWatcher(() => getTodoList(currentPage.value), [currentPage], {\n    immediate: true\n  });\n\n  // Pre-fetch the data of the next page when the current page request is successful\n  // Realize that there is no need to wait for the request when turning to the next page\n  onSuccess(() => {\n    fetch(getTodoList(currentPage.value + 1));\n  });\n<\/script>\n"))),(0,r.kt)(i.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { useState } from 'react';\n\n// method instance creation function\nconst getTodoList = currentPage => {\n  return alovaInstance.Get('/tood/list', {\n    params: {\n      currentPage,\n      pageSize: 10\n    }\n  });\n};\n\nconst App = () => {\n  const { fetch } = useFetcher();\n  const [currentPage, setCurrentPage] = useState(1);\n  const { data, onSuccess } = useWatcher(() => getTodoList(currentPage), [currentPage], {\n    immediate: true\n  });\n\n  // Pre-fetch the data of the next page when the current page request is successful\n  // Realize that there is no need to wait for the request when turning to the next page\n  onSuccess(() => {\n    fetch(getTodoList(currentPage + 1));\n  });\n\n  return {\n    /* ... */\n  };\n};\n"))),(0,r.kt)(i.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<script>\n  import { writable } from 'svelte/store';\n\n  // method instance creation function\n  const getTodoList = currentPage => {\n    return alovaInstance.Get('/tood/list', {\n      params: {\n        currentPage,\n        pageSize: 10\n      }\n    });\n  };\n\n  const { fetch } = useFetcher();\n  const currentPage = writable(1);\n  const { data, onSuccess } = useWatcher(() => getTodoList($currentPage), [currentPage], {\n    immediate: true\n  });\n\n  // Pre-fetch the data of the next page when the current page request is successful\n  // Realize that there is no need to wait for the request when turning to the next page\n  onSuccess(() => {\n    fetch(getTodoList($currentPage + 1));\n  });\n<\/script>\n\n\x3c!-- views... --\x3e\n")))),(0,r.kt)("admonition",{title:"Notes",type:"caution"},(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"After the ",(0,r.kt)("inlineCode",{parentName:"p"},"useFetcher")," request is completed, only the cache is updated, and if it is found that there is a ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," state under the ",(0,r.kt)("inlineCode",{parentName:"p"},"Method")," instance, it will also be updated synchronously to ensure consistent page data. This is ",(0,r.kt)("inlineCode",{parentName:"p"},"useFetcher")," for cross-module/ The component's guarantee that the view is updated.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"It ignores the cache to force the request by default, and you can also close it in the following ways."))),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"useFetcher({\n  force: false\n});\n"))),(0,r.kt)("p",null,"For more information about forcing a request to be sent, see ","[Advanced-Force Sending Request]","(#Force Sending Request)"))}p.isMDXComponent=!0}}]);