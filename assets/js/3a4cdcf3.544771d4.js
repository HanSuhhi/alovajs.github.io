"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[3311],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>p});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,o=e.originalType,c=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=l(a),p=s,m=u["".concat(c,".").concat(p)]||u[p]||h[p]||o;return a?n.createElement(m,i(i({ref:t},d),{},{components:a})):n.createElement(m,i({ref:t},d))}));function p(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=a.length,i=new Array(o);i[0]=u;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r.mdxType="string"==typeof e?e:s,i[1]=r;for(var l=2;l<o;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(7294),s=a(6010);const o="tabItem_Ymn6";function i(e){let{children:t,hidden:a,className:i}=e;return n.createElement("div",{role:"tabpanel",className:(0,s.Z)(o,i),hidden:a},t)}},5488:(e,t,a)=>{a.d(t,{Z:()=>p});var n=a(7462),s=a(7294),o=a(6010),i=a(2389),r=a(7392),c=a(7094),l=a(2466);const d="tabList__CuJ",h="tabItem_LNqP";function u(e){var t;const{lazy:a,block:i,defaultValue:u,values:p,groupId:m,className:g}=e,y=s.Children.map(e.children,(e=>{if((0,s.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=p??y.map((e=>{let{props:{value:t,label:a,attributes:n}}=e;return{value:t,label:a,attributes:n}})),f=(0,r.l)(b,((e,t)=>e.value===t.value));if(f.length>0)throw new Error(`Docusaurus error: Duplicate values "${f.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const v=null===u?u:u??(null==(t=y.find((e=>e.props.default)))?void 0:t.props.value)??y[0].props.value;if(null!==v&&!b.some((e=>e.value===v)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${v}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:w,setTabGroupChoices:D}=(0,c.U)(),[k,T]=(0,s.useState)(v),C=[],{blockElementScrollPositionUntilNextRender:E}=(0,l.o5)();if(null!=m){const e=w[m];null!=e&&e!==k&&b.some((t=>t.value===e))&&T(e)}const L=e=>{const t=e.currentTarget,a=C.indexOf(t),n=b[a].value;n!==k&&(E(t),T(n),null!=m&&D(m,String(n)))},O=e=>{var t;let a=null;switch(e.key){case"Enter":L(e);break;case"ArrowRight":{const t=C.indexOf(e.currentTarget)+1;a=C[t]??C[0];break}case"ArrowLeft":{const t=C.indexOf(e.currentTarget)-1;a=C[t]??C[C.length-1];break}}null==(t=a)||t.focus()};return s.createElement("div",{className:(0,o.Z)("tabs-container",d)},s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":i},g)},b.map((e=>{let{value:t,label:a,attributes:i}=e;return s.createElement("li",(0,n.Z)({role:"tab",tabIndex:k===t?0:-1,"aria-selected":k===t,key:t,ref:e=>C.push(e),onKeyDown:O,onClick:L},i,{className:(0,o.Z)("tabs__item",h,null==i?void 0:i.className,{"tabs__item--active":k===t})}),a??t)}))),a?(0,s.cloneElement)(y.filter((e=>e.props.value===k))[0],{className:"margin-top--md"}):s.createElement("div",{className:"margin-top--md"},y.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==k})))))}function p(e){const t=(0,i.Z)();return s.createElement(u,(0,n.Z)({key:String(t)},e))}},6725:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>h});var n=a(7462),s=(a(7294),a(3905)),o=a(5488),i=a(5162);const r={title:"Manually update the cache",sidebar_position:40},c=void 0,l={unversionedId:"response-data-management/custom-set-cache-data",id:"response-data-management/custom-set-cache-data",title:"Manually update the cache",description:"Some service interfaces support batch request data, which means that it is always composed of indeterminate sets of response data. When we want to batch request data when initializing the page, and then request only a single piece of data in the interaction, it will cause caching penetration problem.",source:"@site/docs/05-response-data-management/04-custom-set-cache-data.md",sourceDirName:"05-response-data-management",slug:"/response-data-management/custom-set-cache-data",permalink:"/response-data-management/custom-set-cache-data",draft:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/05-response-data-management/04-custom-set-cache-data.md",tags:[],version:"current",sidebarPosition:40,frontMatter:{title:"Manually update the cache",sidebar_position:40},sidebar:"tutorialSidebar",previous:{title:"Update response data across pages/modules",permalink:"/response-data-management/update-response-data-across-modules"},next:{title:"Next step",permalink:"/category/next-step"}},d={},h=[{value:"Update static cache data",id:"update-static-cache-data",level:2},{value:"Dynamic cache data update",id:"dynamic-cache-data-update",level:2},{value:"interrupt cache update",id:"interrupt-cache-update",level:2}],u={toc:h};function p(e){let{components:t,...a}=e;return(0,s.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Some service interfaces support batch request data, which means that it is always composed of indeterminate sets of response data. When we want to batch request data when initializing the page, and then request only a single piece of data in the interaction, it will cause caching penetration problem."),(0,s.kt)("p",null,"For example, we need to obtain the todo list data by date. During initialization, we obtained the data from May 1st to 5th and 5 days in one request, and then the user obtained the data of May 1st again during the operation. Hit the May 1st data during initialization, because the initialized 5-day data are stored together instead of being cached separately. At this time, we can manually create a single response cache for the 5-day data, so that we can Solve the problem of cache penetration when a single data request is made."),(0,s.kt)("h2",{id:"update-static-cache-data"},"Update static cache data"),(0,s.kt)(o.Z,{mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},"<template>\n  <button @click=\"handleTodolistToggle\">Switch date, hit cache</button>\n</template>\n<script setup>\n  import { setCacheData } from 'alova';\n  import { ref } from 'vue';\n\n  const getTodoListByDate = dateList =>\n    alovaInstance.Get('/todo/list/dates', {\n      params: { dateList }\n    });\n  // Get 5 days of data in batches during initialization\n  const dates = ref(['2022-05-01', '2022-05-02', '2022-05-03', '2022-05-04', '2022-05-05']);\n  const {\n    // ...\n    onSuccess\n  } = useWatcher(() => getTodoListByDate(dates.value.join()), [dates], {\n    immediate: true\n  });\n  onSuccess(todoListDates => {\n    if (todoListDates.length <= 1) {\n      return;\n    }\n\n    // highlight-start\n    // By default, these 5 days of data will be cached together in a key\n    // In order to make subsequent requests for a certain day's data also hit the cache, we can disassemble the 5-day data into daily, and manually set the response cache one after another through setCacheData\n    todoListDates.forEach(todoDate => {\n      // setCacheData parameter description:\n      // Parameter 1: method instance object, which is used to specify the cache key\n      // parameter 2: cache data\n      setCacheData(getTodoListByDate(todoDate.date), [todoDate]);\n    });\n    // highlight-end\n  });\n\n  // highlight-start\n  const handleTodolistToggle = () => {\n    // At this point, when the switch date is May 1, it will hit the response cache we manually set.\n    // The dates value is being listened to by useWatcher, so changing it automatically triggers the request\n    dates.value = ['2022-05-01'];\n  };\n  // highlight-end\n<\/script>\n"))),(0,s.kt)(i.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"import { setCacheData } from 'alova';\nimport { useState } from 'react';\n\nconst getTodoListByDate = dateList =>\n  alovaInstance.Get('/todo/list/dates', {\n    params: { dateList }\n  });\n\nconst App = () => {\n  // Get 5 days of data in batches during initialization\n  const [dates, setDates] = useState(['2022-05-01', '2022-05-02', '2022-05-03', '2022-05-04', '2022-05-05']);\n  const {\n    // ...\n    onSuccess\n  } = useWatcher(() => getTodoListByDate(dates.join()), [dates], {\n    immediate: true\n  });\n  onSuccess(todoListDates => {\n    if (todoListDates.length <= 1) {\n      return;\n    }\n\n    // highlight-start\n    // By default, these 5 days of data will be cached together in a key\n    // In order to make subsequent requests for a certain day's data also hit the cache, we can disassemble the 5-day data into daily, and manually set the response cache one by one through setCacheData\n    // The first parameter of setCacheData is the method instance object, which is used to specify the cache key\n    // The second parameter is the cache data\n    todoListDates.forEach(todoDate => {\n      setCacheData(getTodoListByDate(todoDate.date), [todoDate]);\n    });\n    // highlight-end\n  });\n\n  // highlight-start\n  const handleTodolistToggle = () => {\n    // At this point, when the switch date is May 1, it will hit the response cache we manually set.\n    // The dates value is being listened to by useWatcher, so changing it automatically triggers the request\n    setDates(['2022-05-01']);\n  };\n  // highlight-end\n\n  return <button onClick={handleTodolistToggle}>Switch date, hit cache</button>;\n};\n"))),(0,s.kt)(i.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},"<script>\n  import { setCacheData } from 'alova';\n  import { writable } from 'svelte/store';\n\n  const getTodoListByDate = dateList =>\n    alovaInstance.Get('/todo/list/dates', {\n      params: { dateList }\n    });\n  // Get 5 days of data in batches during initialization\n  const dates = writable(['2022-05-01', '2022-05-02', '2022-05-03', '2022-05-04', '2022-05-05']);\n  const {\n    // ...\n    onSuccess\n  } = useWatcher(() => getTodoListByDate($dates.join()), [dates], {\n    immediate: true\n  });\n  onSuccess(todoListDates => {\n    if (todoListDates.length <= 1) {\n      return;\n    }\n\n    // highlight-start\n    // By default, these 5 days of data will be cached together in a key\n    // In order to make subsequent requests for a certain day's data also hit the cache, we can disassemble the 5-day data into daily, and manually set the response cache one by one through setCacheData\n    // The first parameter of setCacheData is the method instance object, which is used to specify the cache key\n    // The second parameter is the cache data\n    todoListDates.forEach(todoDate => {\n      setCacheData(getTodoListByDate(todoDate.date), [todoDate]);\n    });\n    // highlight-end\n  });\n\n  // highlight-start\n  const handleTodolistToggle = () => {\n    // At this point, when the switch date is May 1, it will hit the response cache we manually set.\n    // The dates value is being listened to by useWatcher, so changing it automatically triggers the request\n    $dates = ['2022-05-01'];\n  };\n  // highlight-end\n<\/script>\n<button on:click=\"{handleTodolistToggle}\">Switch date, hit cache</button>\n")))),(0,s.kt)("h2",{id:"dynamic-cache-data-update"},"Dynamic cache data update"),(0,s.kt)("p",null,"You can also pass a callback function to ",(0,s.kt)("inlineCode",{parentName:"p"},"setCacheData")," to dynamically calculate the cache data and return the cache data that needs to be updated."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},"setCacheData(getTodoListByDate('2022-10-01'), oldCache => {\n  // return the data to be cached\n  return {\n    ...oldCache,\n    expire: isAfter('2022-10-01', new Date())\n  };\n});\n")),(0,s.kt)("h2",{id:"interrupt-cache-update"},"interrupt cache update"),(0,s.kt)("p",null,"You can also interrupt the cache update by returning ",(0,s.kt)("inlineCode",{parentName:"p"},"false")," in the ",(0,s.kt)("inlineCode",{parentName:"p"},"setCacheData")," callback function."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},"setCacheData(getTodoListByDate('2022-10-01'), oldCache => {\n  const isExpired = isAfter('2022-10-01', new Date());\n  if (!isExpired) {\n    return false; // interrupt cache update\n  }\n  return undefined; // update the cache to undefined\n});\n")))}p.isMDXComponent=!0}}]);