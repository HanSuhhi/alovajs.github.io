"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[3303],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var d=n.createContext({}),l=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=l(e.components);return n.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,d=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(a),h=o,m=u["".concat(d,".").concat(h)]||u[h]||c[h]||r;return a?n.createElement(m,i(i({ref:t},p),{},{components:a})):n.createElement(m,i({ref:t},p))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=u;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9118:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var n=a(7462),o=(a(7294),a(3905));const r={title:"Update response data across pages/modules",sidebar_position:30},i=void 0,s={unversionedId:"response-data-management/update-response-data-across-modules",id:"response-data-management/update-response-data-across-modules",title:"Update response data across pages/modules",description:"In the example in the previous section [Active Invalidate Response Cache] (../response-data-management/invalidate-response-cache ), when the user clicks on an item in the todo list, enter the todo details page and execute it At this time, we hope that the todo list data in the previous page will also be updated to the edited content. Using the methods of useFetcher and invalidateCache will re-initiate the request. Is there any method that does not require re-request?",source:"@site/docs/05-response-data-management/03-update-response-data-across-modules.md",sourceDirName:"05-response-data-management",slug:"/response-data-management/update-response-data-across-modules",permalink:"/response-data-management/update-response-data-across-modules",draft:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/05-response-data-management/03-update-response-data-across-modules.md",tags:[],version:"current",sidebarPosition:30,frontMatter:{title:"Update response data across pages/modules",sidebar_position:30},sidebar:"tutorialSidebar",previous:{title:"Actively Invalidate Response Cache",permalink:"/response-data-management/invalidate-response-cache"},next:{title:"Manually update the cache",permalink:"/response-data-management/custom-set-cache-data"}},d={},l=[{value:"General usage",id:"general-usage",level:2}],p={toc:l};function c(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In the example in the previous section ","[Active Invalidate Response Cache]"," (../response-data-management/invalidate-response-cache ), when the user clicks on an item in the todo list, enter the todo details page and execute it At this time, we hope that the todo list data in the previous page will also be updated to the edited content. Using the methods of ",(0,o.kt)("inlineCode",{parentName:"p"},"useFetcher")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"invalidateCache")," will re-initiate the request. Is there any method that does not require re-request?"),(0,o.kt)("p",null,"Of course there is!"),(0,o.kt)("h2",{id:"general-usage"},"General usage"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { updateState } from 'alova';\n\n// the todo item being edited\nconst editingTodo = {\n  id: 1,\n  title: 'todo1',\n  time: '09:00'\n};\n\nconst { send, onSuccess } = useRequest(createTodoPoster, { immediate: false });\n\n// After the submission is successful, the todo data cache of the first page is fixed to be invalidated\nonSuccess(() => {\n  // highlight-start\n  // After the submission is successful, the todo data data of the first page is fixedly modified\n  // The first parameter is the Method instance, and the second is the callback function containing the original cached data, which needs to return the modified data\n  updateState(getTodoList(1), todoList => {\n    return todoList.map(item => {\n      if (item.id === editingTodo.id) {\n        return {\n          ...item,\n          ...editingTodo\n        };\n      }\n      return item;\n    });\n  });\n  // highlight-end\n});\n")),(0,o.kt)("admonition",{title:"note",type:"caution"},(0,o.kt)("ol",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ol"},"When updating the state through ",(0,o.kt)("inlineCode",{parentName:"li"},"updateState"),", if the cache (memory cache and persistent cache) is detected, it will also update the cache with new data."),(0,o.kt)("li",{parentName:"ol"},"Alova manages the status returned by the hook only when a request is initiated using useRequest and useWatcher. The reason is that the response status is generated and saved through a Method instance, but when no request is initiated, the url, Parameters such as params, query, headers, etc. are still uncertain.\n:::")),(0,o.kt)("h2",{parentName:"admonition",id:"advanced-usage"},"Advanced usage"),(0,o.kt)("p",{parentName:"admonition"},"Many times we have such a requirement. We hope that when the todo item is created silently, ",(0,o.kt)("inlineCode",{parentName:"p"},"updateState")," is called immediately to update the data to display the new todo item immediately, and at the same time, we also hope to update the ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," again after the todo item is created. , at this point you can use ",(0,o.kt)("a",{parentName:"p",href:"../next-step/delayed-data-update"},"delayed data update"))))}c.isMDXComponent=!0}}]);