"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[5486],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(t),g=i,m=c["".concat(s,".").concat(g)]||c[g]||d[g]||r;return t?a.createElement(m,o(o({ref:n},p),{},{components:t})):a.createElement(m,o({ref:n},p))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=t[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>o});var a=t(7294),i=t(6010);const r="tabItem_Ymn6";function o(e){let{children:n,hidden:t,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,o),hidden:t},n)}},4866:(e,n,t)=>{t.d(n,{Z:()=>w});var a=t(7462),i=t(7294),r=t(6010),o=t(2466),l=t(6550),s=t(1980),u=t(7392),p=t(12);function d(e){return function(e){var n;return(null==(n=i.Children.map(e,(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:n.filter(Boolean))??[]}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:i}}=e;return{value:n,label:t,attributes:a,default:i}}))}function c(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=n??d(t);return function(e){const n=(0,u.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function g(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const a=(0,l.k6)(),r=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,s._X)(r),(0,i.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(a.location.search);n.set(r,e),a.replace({...a.location,search:n.toString()})}),[r,a])]}function h(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,r=c(e),[o,l]=(0,i.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!g({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:r}))),[s,u]=m({queryString:t,groupId:a}),[d,h]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,r]=(0,p.Nk)(t);return[a,(0,i.useCallback)((e=>{t&&r.set(e)}),[t,r])]}({groupId:a}),f=(()=>{const e=s??d;return g({value:e,tabValues:r})?e:null})();(0,i.useLayoutEffect)((()=>{f&&l(f)}),[f]);return{selectedValue:o,selectValue:(0,i.useCallback)((e=>{if(!g({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),h(e)}),[u,h,r]),tabValues:r}}var f=t(2389);const b="tabList__CuJ",v="tabItem_LNqP";function y(e){let{className:n,block:t,selectedValue:l,selectValue:s,tabValues:u}=e;const p=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.o5)(),c=e=>{const n=e.currentTarget,t=p.indexOf(n),a=u[t].value;a!==l&&(d(n),s(a))},g=e=>{var n;let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=p.indexOf(e.currentTarget)+1;t=p[n]??p[0];break}case"ArrowLeft":{const n=p.indexOf(e.currentTarget)-1;t=p[n]??p[p.length-1];break}}null==(n=t)||n.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":t},n)},u.map((e=>{let{value:n,label:t,attributes:o}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:l===n?0:-1,"aria-selected":l===n,key:n,ref:e=>p.push(e),onKeyDown:g,onClick:c},o,{className:(0,r.Z)("tabs__item",v,null==o?void 0:o.className,{"tabs__item--active":l===n})}),t??n)})))}function k(e){let{lazy:n,children:t,selectedValue:a}=e;const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=r.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},r.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function N(e){const n=h(e);return i.createElement("div",{className:(0,r.Z)("tabs-container",b)},i.createElement(y,(0,a.Z)({},e,n)),i.createElement(k,(0,a.Z)({},e,n)))}function w(e){const n=(0,f.Z)();return i.createElement(N,(0,a.Z)({key:String(n)},e))}},6470:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>g,frontMatter:()=>l,metadata:()=>u,toc:()=>d});var a=t(7462),i=(t(7294),t(3905)),r=t(4866),o=t(5162);const l={title:"Pagination request strategy",sidebar_position:20},s=void 0,u={unversionedId:"strategy/usePagination",id:"strategy/usePagination",title:"Pagination request strategy",description:"Before using extension hooks, make sure you are familiar with basic usage of alova.",source:"@site/docs/07-strategy/02-usePagination.md",sourceDirName:"07-strategy",slug:"/strategy/usePagination",permalink:"/strategy/usePagination",draft:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/07-strategy/02-usePagination.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{title:"Pagination request strategy",sidebar_position:20},sidebar:"tutorialSidebar",previous:{title:"What more?",permalink:"/strategy/sensorless-data-interaction/what-more"},next:{title:"form submit strategy",permalink:"/strategy/useForm"}},p={},d=[{value:"Example",id:"example",level:2},{value:"Features",id:"features",level:2},{value:"Install",id:"install",level:2},{value:"Usage",id:"usage",level:2},{value:"Display list data",id:"display-list-data",level:3},{value:"Specify pagination data",id:"specify-pagination-data",level:3},{value:"Enable append mode",id:"enable-append-mode",level:3},{value:"Preload adjacent page data",id:"preload-adjacent-page-data",level:3},{value:"Listening filter conditions",id:"listening-filter-conditions",level:3},{value:"Close initialization request",id:"close-initialization-request",level:3},{value:"list manipulation functions",id:"list-manipulation-functions",level:2},{value:"Insert list item",id:"insert-list-item",level:3},{value:"Remove list item",id:"remove-list-item",level:3},{value:"Update data items",id:"update-data-items",level:3},{value:"Refresh the data of the specified page",id:"refresh-the-data-of-the-specified-page",level:3},{value:"Manually update list data",id:"manually-update-list-data",level:3},{value:"Reset list",id:"reset-list",level:3},{value:"Limitation",id:"limitation",level:2}],c={toc:d};function g(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Before using extension hooks, make sure you are familiar with basic usage of alova.")),(0,i.kt)("p",null,"A hook designed for paging scenarios, which can help you automatically manage paging data, preload data, reduce unnecessary data refresh, improve fluency by 300%, and reduce coding difficulty by 50%","*","*",". You can use it in the two paging scenarios of pull-down loading and page number flipping. This hook provides a wealth of features to help your application create better performance and more convenient paging functions."),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/example/paginated-list"},"page list")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/example/load-more"},"Pull down to load more")),(0,i.kt)("h2",{id:"features"},"Features"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u2728 Rich and comprehensive paging status;"),(0,i.kt)("li",{parentName:"ul"},"\u2728 Rich and comprehensive pagination events;"),(0,i.kt)("li",{parentName:"ul"},"\u2728 Change page, pageSize to automatically get specified paging data;"),(0,i.kt)("li",{parentName:"ul"},"\u2728Data caching, no need to repeatedly request list data of the same parameters;"),(0,i.kt)("li",{parentName:"ul"},"\u2728 Front and back pages are preloaded, no waiting for page turning;"),(0,i.kt)("li",{parentName:"ul"},"\u2728Search condition monitoring automatically reacquires pages;"),(0,i.kt)("li",{parentName:"ul"},"\u2728 Support adding, editing and deleting list data;"),(0,i.kt)("li",{parentName:"ul"},"\u2728 Support refreshing the data of the specified page without reset;"),(0,i.kt)("li",{parentName:"ul"},"\u2728 Request-level search anti-shake, no need to maintain by yourself;")),(0,i.kt)("h2",{id:"install"},"Install"),(0,i.kt)(r.Z,{groupId:"framework",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# npm\nnpm install @alova/scene-vue --save\n#yarn\nyarn add @alova/scene-vue\n\n"))),(0,i.kt)(o.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# npm\nnpm install @alova/scene-react --save\n#yarn\nyarn add @alova/scene-react\n\n"))),(0,i.kt)(o.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# npm\nnpm install @alova/scene-svelte --save\n#yarn\nyarn add @alova/scene-svelte\n\n")))),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("h3",{id:"display-list-data"},"Display list data"),(0,i.kt)(r.Z,{groupId:"framework",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},'<template>\n  <div\n    v-for="item in data"\n    :key="item.id">\n    <span>{{ item.name }}</span>\n  </div>\n  <button @click="handlePrevPage">Previous page</button>\n  <button @click="handleNextPage">next page</button>\n  <button @click="handleSetPageSize">Set the number of pages</button>\n  <span>There are {{ pageCount }} pages</span>\n  <span>A total of {{ total }} data</span>\n</template>\n\n<script setup>\n  import { queryStudents } from \'./api.js\';\n  import { usePagination } from \'@alova/scene-vue\';\n\n  const {\n    // loading state\n    loading,\n\n    // list data\n    data,\n\n    // is it the last page\n    // This parameter can be used to determine whether it needs to be loaded during pull-down loading\n    isLastPage,\n\n    // The current page number, changing this page number will automatically trigger the request\n    page,\n\n    // Number of data items per page\n    pageSize,\n\n    // number of paging pages\n    pageCount,\n\n    // total amount of data\n    total\n  } = usePagination(\n    // Method instance acquisition function, it will receive page and pageSize, and return a Method instance\n    (page, pageSize) => queryStudents(page, pageSize),\n    {\n      // Initial data before the request (data format returned by the interface)\n      initialData: {\n        total: 0,\n        data: []\n      },\n      initialPage: 1, // initial page number, default is 1\n      initialPageSize: 10 // The initial number of data items per page, the default is 10\n    }\n  );\n\n  // Turn to the previous page, the request will be sent automatically after the page value changes\n  const handlePrevPage = () => {\n    page.value--;\n  };\n\n  // Turn to the next page, the request will be sent automatically after the page value changes\n  const handleNextPage = () => {\n    page.value++;\n  };\n\n  // Change the number of pages, the request will be sent automatically after the pageSize value is changed\n  const handleSetPageSize = () => {\n    pageSize.value = 20;\n  };\n<\/script>\n'))),(0,i.kt)(o.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import { queryStudents } from './api.js';\nimport { usePagination } from '@alova/scene-react';\n\nconst App = () => {\n  const {\n    // loading state\n    loading,\n\n    // list data\n    data,\n\n    // is it the last page\n    // This parameter can be used to determine whether it needs to be loaded during pull-down loading\n    isLastPage,\n\n    // The current page number, changing this page number will automatically trigger the request\n    page: [page, setPage],\n\n    // Number of data items per page\n    pageSize: [page, setPageSize],\n\n    // number of paging pages\n    pageCount,\n\n    // total amount of data\n    total\n  } = usePagination(\n    // Method instance acquisition function, it will receive page and pageSize, and return a Method instance\n    (page, pageSize) => queryStudents(page, pageSize),\n    {\n      // Initial data before the request (data format returned by the interface)\n      initialData: {\n        total: 0,\n        data: []\n      },\n      initialPage: 1, // initial page number, default is 1\n      initialPageSize: 10 // The initial number of data items per page, the default is 10\n    }\n  );\n\n  // Turn to the previous page, the request will be sent automatically after the page value changes\n  const handlePrevPage = () => {\n    setPage(value => value - 1);\n  };\n\n  // Turn to the next page, the request will be sent automatically after the page value changes\n  const handleNextPage = () => {\n    setPage(value => value + 1);\n  };\n\n  // Change the number of pages, the request will be sent automatically after the pageSize value is changed\n  const handleSetPageSize = () => {\n    setPageSize(20);\n  };\n\n  return (\n    <div>\n      {data.map(item => (\n        <div key={item.id}>\n          <span>{item.name}</span>\n        </div>\n      ))}\n      <button onClick={handlePrevPage}>Previous page</button>\n      <button onClick={handleNextPage}>Next Page</button>\n      <button onClick={handleSetPageSize}>Set the number per page</button>\n      <span>There are {pageCount} pages</span>\n      <span>A total of {total} pieces of data</span>\n    </div>\n  );\n};\n"))),(0,i.kt)(o.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},'<script>\n  import { queryStudents } from \'./api.js\';\n  import { usePagination } from \'@alova/scene-svelte\';\n\n  const {\n    // loading state\n    loading,\n\n    // list data\n    data,\n\n    // is it the last page\n    // This parameter can be used to determine whether it needs to be loaded during pull-down loading\n    isLastPage,\n\n    // The current page number, changing this page number will automatically trigger the request\n    page,\n\n    // Number of data items per page\n    pageSize,\n\n    // number of paging pages\n    pageCount,\n\n    // total amount of data\n    total\n  } = usePagination(\n    // Method instance acquisition function, it will receive page and pageSize, and return a Method instance\n    (page, pageSize) => queryStudents(page, pageSize),\n    {\n      // Initial data before the request (data format returned by the interface)\n      initialData: {\n        total: 0,\n        data: []\n      },\n      initialPage: 1, // initial page number, default is 1\n      initialPageSize: 10 // The initial number of data items per page, the default is 10\n    }\n  );\n\n  // Turn to the previous page, the request will be sent automatically after the page value changes\n  const handlePrevPage = () => {\n    $page--;\n  };\n\n  // Turn to the next page, the request will be sent automatically after the page value changes\n  const handleNextPage = () => {\n    $page++;\n  };\n\n  // Change the number of pages, the request will be sent automatically after the pageSize value is changed\n  const handleSetPageSize = () => {\n    $pageSize = 20;\n  };\n<\/script>\n\n{#each $data as item}\n<div>\n  <span>{item.name}</span>\n</div>\n{/each}\n<button on:click="{handlePrevPage}">Previous page</button>\n<button on:click="{handleNextPage}">Next Page</button>\n<button on:click="{handleSetPageSize}">Set the number per page</button>\n<span>There are {pageCount} pages</span>\n<span>A total of {total} pieces of data</span>\n')))),(0,i.kt)("h3",{id:"specify-pagination-data"},"Specify pagination data"),(0,i.kt)("p",null,"The data structure returned by each paging data interface is different, so we need to tell ",(0,i.kt)("inlineCode",{parentName:"p"},"usePagination")," the list data and the total number of items separately, so as to help us manage the paging data."),(0,i.kt)("p",null,"Suppose the data format returned by your paging interface is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface PaginationData {\n  totalNumber: number;\n  list: any[];\n}\n")),(0,i.kt)("p",null,"At this point, you need to return the list data and the total number of items in the form of a function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"usePagination((page, pageSize) => queryStudents(page, pageSize), {\n  //...\n  // highlight-start\n  total: response => response.totalNumber,\n  data: response => response.list\n  // highlight-end\n});\n")),(0,i.kt)("p",null,"If you don't specify the total and data callback functions, they will get data in the following ways by default."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const total = response => response.total;\nconst data = response => response.data;\n")),(0,i.kt)("admonition",{title:"Caution",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The data callback function must return a list of data, indicating the data set used in paging, and total is mainly used to calculate the current page number. If no number is returned in the total callback function, it will pass whether the number of requested lists is less than the pageSize value To determine whether the current page is the last page, which is generally used for pull-down loading.")),(0,i.kt)("h3",{id:"enable-append-mode"},"Enable append mode"),(0,i.kt)("p",null,"By default, the original list data will be replaced when the page is turned, and the append mode will append the data of the next page to the bottom of the current list when the page is turned. A common usage scenario is to pull down to load more."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"usePagination((page, pageSize) => queryStudents(page, pageSize), {\n  //...\n  // highlight-start\n  append: true\n  // highlight-end\n});\n")),(0,i.kt)("h3",{id:"preload-adjacent-page-data"},"Preload adjacent page data"),(0,i.kt)("p",null,"In order to provide a better experience for pagination, when the previous and next pages of the current page meet the conditions, it will be automatically preloaded, so that when the user turns the page, the data can be displayed directly without waiting. This is the default behavior. If you don't want to preload the data of adjacent pages, you can turn it off in the following way."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"usePagination((page, pageSize) => queryStudents(page, pageSize), {\n  //...\n  // highlight-start\n  preloadPreviousPage: false, // turn off preloading previous page data\n  preloadNextPage: false // turn off preloading next page data\n  // highlight-end\n});\n")),(0,i.kt)("p",null,"In addition to ",(0,i.kt)("inlineCode",{parentName:"p"},"onSuccess, onError, onComplete")," request events, when preloading is triggered, you can also know the preloading status through ",(0,i.kt)("inlineCode",{parentName:"p"},"fetching"),", and you can also listen to preloading request events through ",(0,i.kt)("inlineCode",{parentName:"p"},"onFetchSuccess, onFetchError, onFetchComplete"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const {\n  // preload state\n  fetching,\n\n  // preload success event binding function\n  onFetchSuccess,\n\n  // preload error event binding function\n  onFetchError,\n\n  // Preloading complete event binding function\n  onFetchComplete\n} = usePagination((page, pageSize) => queryStudents(page, pageSize), {\n  //...\n});\n")),(0,i.kt)("h3",{id:"listening-filter-conditions"},"Listening filter conditions"),(0,i.kt)("p",null,"In many cases, the list needs to be filtered by conditions. At this time, the re-request can be triggered through the status monitoring of ",(0,i.kt)("inlineCode",{parentName:"p"},"usePagination"),", which is the same as ",(0,i.kt)("inlineCode",{parentName:"p"},"useWatcher")," provided by alova."),(0,i.kt)("p",null,"For example, filter by student name, student grade."),(0,i.kt)(r.Z,{groupId:"framework",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},"<template>\n  \x3c!-- highlight-start --\x3e\n  <input v-model=\"studentName\" />\n  <select v-model=\"clsName\">\n    <option value=\"1\">Class 1</option>\n    <option value=\"2\">Class 2</option>\n    <option value=\"3\">Class 3</option>\n  </select>\n  \x3c!-- highlight-end --\x3e\n  \x3c!-- ... --\x3e\n</template>\n\n<script setup>\n  import { ref } from 'vue';\n  import { queryStudents } from './api.js';\n  import { usePagination } from '@alova/scene-vue';\n\n  // search condition status\n  const studentName = ref('');\n  const clsName = ref('');\n  const {\n    //...\n  } = usePagination((page, pageSize) => queryStudents(page, pageSize, studentName.value, clsName.value), {\n    //...\n    // highlight-start\n    watchingStates: [studentName, clsName]\n    // highlight-end\n  });\n<\/script>\n"))),(0,i.kt)(o.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import { queryStudents } from './api.js';\nimport { usePagination } from '@alova/scene-react';\n\nconst App = () => {\n   // search condition status\n   const [studentName, setStudentName] = useState('');\n   const [clsName, setClsName] = useState('');\n   const {\n     //...\n   } = usePagination(\n     (page, pageSize) => queryStudents(page, pageSize, studentName, clsName),\n     {\n       //...\n       // highlight-start\n       watchingStates: [studentName, clsName]\n       // highlight-end\n     }\n   );\n\n   return (\n     // highlight-start\n     <input value={studentName} onChange={({ target }) => setStudentName(target. value)} />\n     <select value={clsName} onChange={({ target }) => setClsName(target. value)}>\n       <option value=\"1\">Class 1</option>\n       <option value=\"2\">Class 2</option>\n       <option value=\"3\">Class 3</option>\n     </select>\n     // highlight-end\n     //...\n   );\n};\n"))),(0,i.kt)(o.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},"<script>\n  import { queryStudents } from './api.js';\n  import { usePagination } from '@alova/scene-svelte';\n  import { writable } from 'svelte/store';\n\n  // search condition status\n  const studentName = writable('');\n  const clsName = writable('');\n  const {\n    //...\n  } = usePagination((page, pageSize) => queryStudents(page, pageSize, $studentName, $clsName), {\n    //...\n    // highlight-start\n    watchingStates: [studentName, clsName]\n    // highlight-end\n  });\n<\/script>\n\n\x3c!-- highlight-start --\x3e\n<input bind:value=\"{studentName}\" />\n<select bind:value=\"{clsName}\">\n  <option value=\"1\">Class 1</option>\n  <option value=\"2\">Class 2</option>\n  <option value=\"3\">Class 3</option>\n</select>\n\x3c!-- highlight-end --\x3e\n\x3c!-- ... --\x3e\n")))),(0,i.kt)("p",null,"Same as ",(0,i.kt)("inlineCode",{parentName:"p"},"useWatcher"),", you can also implement request debounce by specifying ",(0,i.kt)("inlineCode",{parentName:"p"},"debounce"),", for details, please refer to ",(0,i.kt)("a",{parentName:"p",href:"/learning/use-watcher"},"useWatcher's debounce parameter setting"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"usePagination((page, pageSize) => queryStudents(page, pageSize, studentName, clsName), {\n  //...\n  // highlight-start\n  debounce: 300 // Anti-shake parameters, in milliseconds, can also be set as an array to set the anti-shake time separately for watchingStates\n  // highlight-end\n});\n")),(0,i.kt)("p",null,"It should be noted that ",(0,i.kt)("inlineCode",{parentName:"p"},"debounce")," is achieved by request debounce in ",(0,i.kt)("a",{parentName:"p",href:"/learning/use-watcher"},(0,i.kt)("strong",{parentName:"a"},"useWatcher")),". ",(0,i.kt)("strong",{parentName:"p"},"At the end of the monitoring state, there are two hidden monitoring states of page and pageSize, which can also be set by debounce. ")),(0,i.kt)("p",null,"For example, when ",(0,i.kt)("inlineCode",{parentName:"p"},"watchingStates")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"[studentName, clsName]"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"[studentName, clsName, page, pageSize]")," will be monitored internally, so if you need to set anti-shake for page and pageSize, you can specify ",(0,i.kt)("inlineCode",{parentName:"p"}," [0, 0, 500, 500]"),"."),(0,i.kt)("h3",{id:"close-initialization-request"},"Close initialization request"),(0,i.kt)("p",null,"By default, ",(0,i.kt)("inlineCode",{parentName:"p"},"usePagination")," will initiate a request during initialization, but you can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"immediate")," to turn it off, and then pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"send")," function, or change ",(0,i.kt)("inlineCode",{parentName:"p"},"page")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"pageSize"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"watchingStates"),", etc. state to initiate the request."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"usePagination((page, pageSize) => queryStudents(page, pageSize, studentName, clsName), {\n  //...\n  // highlight-start\n  immediate: false\n  // highlight-end\n});\n")),(0,i.kt)("h2",{id:"list-manipulation-functions"},"list manipulation functions"),(0,i.kt)("p",null,"usePagination provides a fully functional list operation function, which can achieve the same effect as the re-request list without re-requesting the list, which greatly improves the interactive experience of the page. The specific function description continues to look down!"),(0,i.kt)("h3",{id:"insert-list-item"},"Insert list item"),(0,i.kt)("p",null,"You can use it to insert list items to any position in the list, and it will remove the last item after insertion to ensure the same effect as re-requesting the current page data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n  * Insert a piece of data, if the index is not passed in, it will be inserted at the front by default\n  * @param item insert item\n  * @param index insertion position (index)\n  */\ninsert: (item: LD[number], index?: number) => void;\n")),(0,i.kt)("p",null,"The following is an example of returning to the first page and then inserting list items in ",(0,i.kt)("strong",{parentName:"p"},"non-append mode")," (page number flipping scenario):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"page.value = 1;\nnextTick(() => {\n  insert(newItem, 0);\n});\n")),(0,i.kt)("p",null,"The following is an example of scrolling to the top after inserting a list item in ",(0,i.kt)("strong",{parentName:"p"},"append mode")," (drop-down loading scene):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"insert(newItem, 0);\nnextTick(() => {\n  window.scrollTo(0, {});\n});\n")),(0,i.kt)("admonition",{title:"Caution",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"In order to make the data correct, the insert function call will clear all caches.")),(0,i.kt)("h3",{id:"remove-list-item"},"Remove list item"),(0,i.kt)("p",null,"In the case that the next page has a cache, it will use the cache of the next page to add to the end of the list item after removing an item, so as to ensure the same effect as re-requesting the data of the current page. In ",(0,i.kt)("strong",{parentName:"p"},"append mode")," and Behave the same in ",(0,i.kt)("strong",{parentName:"p"},"non-append mode"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n  * Remove a piece of data\n  * @param index index to remove\n  */\nremove: (index: number) => void;\n")),(0,i.kt)("p",null,"But in the following two cases, it will re-initiate the request to refresh the data of the corresponding page:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The next page is not cached"),(0,i.kt)("li",{parentName:"ol"},"The data that exceeds the next page cache list item is continuously called synchronously, and the cache data is not enough to supplement the current page list.")),(0,i.kt)("admonition",{title:"Caution",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"In order to make the data correct, the remove function call will clear all caches.")),(0,i.kt)("h3",{id:"update-data-items"},"Update data items"),(0,i.kt)("p",null,"Use this function when you want to update list items."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n  * Replace a piece of data\n  * @param item replacement item\n  * @param index replacement position (index)\n  */\nreplace: (item: LD[number], index: number) => void;\n")),(0,i.kt)("h3",{id:"refresh-the-data-of-the-specified-page"},"Refresh the data of the specified page"),(0,i.kt)("p",null,"When you do not want to update the list items locally after the data operation, but re-request the data on the server side, you can use refresh to refresh the data on any page, without resetting the list data and letting the user start browsing from the first page again."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n  * Refresh the specified page number data, this function will ignore the cache to force the send request\n  * @param refreshPage refresh page number\n  */\nrefresh: (refreshPage: number) => void;\n")),(0,i.kt)("h3",{id:"manually-update-list-data"},"Manually update list data"),(0,i.kt)("p",null,"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"update")," function to update responsive data, which is similar to ",(0,i.kt)("a",{parentName:"p",href:"/learning/use-request"},"useRequest's update"),", the only difference is that when calling ",(0,i.kt)("inlineCode",{parentName:"p"},"update")," to update ",(0,i.kt)("inlineCode",{parentName:"p"},"data"),", the list data is updated, while non-response data. This is useful when manually clearing list data without reissuing the request."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// case list data\nupdate({\n  data: []\n});\n")),(0,i.kt)("h3",{id:"reset-list"},"Reset list"),(0,i.kt)("p",null,"It will clear all caches and reload the first page."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n  * Reload the list from the first page and clear the cache\n  */\nreload: () => void;\n")),(0,i.kt)("p",null,"##Typescript"),(0,i.kt)(r.Z,{groupId:"framework",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface UsePaginationReturnType<LD extends any[], R> {\n  loading: Ref<boolean>;\n  error: Ref<Error | undefined>;\n  downloading: Ref<Progress>;\n  uploading: Ref<Progress>;\n  page: Ref<number>;\n  pageSize: Ref<number>;\n  data: Ref<LD>;\n  pageCount: ComputedRef<number | undefined>;\n  total: ComputedRef<number | undefined>;\n  isLastPage: ComputedRef<boolean>;\n\n  abort: () => void;\n  send: (...args: any[]) => Promise<R>;\n  onSuccess: (handler: SuccessHandler<R>) => void;\n  onError: (handler: ErrorHandler) => void;\n  onComplete: (handler: CompleteHandler) => void;\n\n  fetching: Ref<boolean>;\n  onFetchSuccess: (handler: SuccessHandler<R>) => void;\n  onFetchError: (handler: ErrorHandler) => void;\n  onFetchComplete: (handler: CompleteHandler) => void;\n  update: (newFrontStates: Partial<FrontRequestState<boolean, LD, Error | undefined, Progress, Progress>>) => void;\n\n  /**\n   * Refresh the specified page number data, this function will ignore the cache to force the send request\n   * @param refreshPage refresh page number\n   */\n  refresh: (refreshPage: number) => void;\n\n  /**\n   * Insert a piece of data\n   * onBefore, insert operation, and onAfter all need to be executed sequentially and asynchronously, because they need to wait for the view to be updated before executing\n   * @param item insert item\n   * @param config insert configuration\n   */\n  insert: (item: LD[number], config?: InsertConfig) => void;\n\n  /**\n   * Remove a piece of data\n   * @param index index to remove\n   */\n  remove: (index: any) => void;\n\n  /**\n   * Reload the list from the first page and clear the cache\n   */\n  reload: () => void;\n}\n\n/**\n * Vue paging hook based on alova.js\n * Automatic management of pagination-related states, preloading of previous and subsequent pages, automatic maintenance of data addition/editing/replacement/removal\n *\n * @param handler method creation function\n * @param config pagination hook configuration\n * @returns {UsePaginationReturnType}\n */\nexport declare function usePagination<\n  S extends Ref,\n  E extends Ref,\n  R,\n  T,\n  RC,\n  RE,\n  RH,\n  LD extends any[],\n  WS extends WatchSource[]\n>(\n  handler: (page: number, pageSize: number) => Method<S, E, R, T, RC, RE, RH>,\n  config: PaginationConfig<R, LD, WS>\n): UsePaginationReturnType<LD, R>;\n"))),(0,i.kt)(o.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"type ReactState<S> = [S, Dispatch<SetStateAction<S>>];\ninterface UsePaginationReturnType<LD extends any[], R> {\n  loading: boolean;\n  error: Error | undefined;\n  downloading: Progress;\n  uploading: Progress;\n  page: ReactState<number>;\n  pageSize: ReactState<number>;\n  data: LD;\n  pageCount: number | undefined;\n  total: number | undefined;\n  isLastPage: boolean;\n\n  abort: () => void;\n  send: (...args: any[]) => Promise<R>;\n  onSuccess: (handler: SuccessHandler<R>) => void;\n  onError: (handler: ErrorHandler) => void;\n  onComplete: (handler: CompleteHandler) => void;\n\n  fetching: boolean;\n  onFetchSuccess: (handler: SuccessHandler<R>) => void;\n  onFetchError: (handler: ErrorHandler) => void;\n  onFetchComplete: (handler: CompleteHandler) => void;\n  update: (newFrontStates: Partial<FrontRequestState<boolean, LD, Error | undefined, Progress, Progress>>) => void;\n\n  /**\n   * Refresh the specified page number data, this function will ignore the cache to force the send request\n   * @param refreshPage refresh page number\n   */\n  refresh: (refreshPage: number) => void;\n\n  /**\n   * Insert a piece of data\n   * onBefore, insert operation, and onAfter all need to be executed sequentially and asynchronously, because they need to wait for the view to be updated before executing\n   * @param item insert item\n   * @param config insert configuration\n   */\n  insert: (item: LD[number], config?: InsertConfig) => void;\n\n  /**\n   * Remove a piece of data\n   * @param index index to remove\n   */\n  remove: (index: any) => void;\n\n  /**\n   * Reload the list from the first page and clear the cache\n   */\n  reload: () => void;\n}\n\n/**\n * React paging hook based on alova.js\n * Automatic management of pagination-related states, preloading of previous and subsequent pages, automatic maintenance of data addition/editing/removal\n *\n * @param handler method creation function\n * @param config pagination hook configuration\n * @returns {UsePaginationReturnType}\n */\nexport declare function usePagination<S, E, R, T, RC, RE, RH, LD extends any[], WS extends DependencyList>(\n  handler: (page: number, pageSize: number) => Method<S, E, R, T, RC, RE, RH>,\n  config: PaginationConfig<R, LD, WS>\n): UsePaginationReturnType<LD, R>;\n"))),(0,i.kt)(o.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface UsePaginationReturnType<LD extends any[], R> {\n  loading: Writable<boolean>;\n  error: Writable<Error | undefined>;\n  downloading: Writable<Progress>;\n  uploading: Writable<Progress>;\n  page: Writable<number>;\n  pageSize: Writable<number>;\n  data: Writable<LD>;\n  pageCount: Readable<number | undefined>;\n  total: Readable<number | undefined>;\n  isLastPage: Readonly<Readable<boolean>>;\n\n  abort: () => void;\n  send: (...args: any[]) => Promise<R>;\n  onSuccess: (handler: SuccessHandler<R>) => void;\n  onError: (handler: ErrorHandler) => void;\n  onComplete: (handler: CompleteHandler) => void;\n\n  fetching: Writable<boolean>;\n  onFetchSuccess: (handler: SuccessHandler<R>) => void;\n  onFetchError: (handler: ErrorHandler) => void;\n  onFetchComplete: (handler: CompleteHandler) => void;\n  update: (newFrontStates: Partial<FrontRequestState<boolean, LD, Error | undefined, Progress, Progress>>) => void;\n\n  /**\n   * Refresh the specified page number data, this function will ignore the cache to force the send request\n   * @param refreshPage refresh page number\n   */\n  refresh: (refreshPage: number) => void;\n\n  /**\n   * Insert a piece of data\n   * onBefore, insert operation, and onAfter all need to be executed sequentially and asynchronously, because they need to wait for the view to be updated before executing\n   * @param item insert item\n   * @param config insert configuration\n   */\n  insert: (item: LD[number], config?: InsertConfig) => void;\n\n  /**\n   * Remove a piece of data\n   * @param index index to remove\n   */\n  remove: (index: any) => void;\n\n  /**\n   * Reload the list from the first page and clear the cache\n   */\n  reload: () => void;\n}\n\n/**\n * svelte paging hook based on alova.js\n * Automatic management of pagination-related states, preloading of previous and subsequent pages, automatic maintenance of data addition/editing/removal\n *\n * @param handler method creation function\n * @param config pagination hook configuration\n * @returns {UsePaginationReturnType}\n */\nexport declare function usePagination<\n  S extends Writable<any>,\n  E extends Writable<any>,\n  R,\n  T,\n  RC,\n  RE,\n  RH,\n  LD extends any[],\n  WS extends Readable<any>[]\n>(\n  handler: (page: number, pageSize: number) => Method<S, E, R, T, RC, RE, RH>,\n  config: PaginationConfig<R, LD, WS>\n): UsePaginationReturnType<LD, R>;\n")))),(0,i.kt)("h2",{id:"limitation"},"Limitation"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Cache replaceholder mode")," and ",(0,i.kt)("strong",{parentName:"p"},"recovery mode")," are temporarily disabled"))}g.isMDXComponent=!0}}]);