"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[5486],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=d(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||c[m]||i;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294),r=n(6010);const i="tabItem_Ymn6";function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,o),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>R});var a=n(7462),r=n(7294),i=n(6010),o=n(2466),s=n(6550),l=n(1980),d=n(7392),u=n(12);function c(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function p(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??c(n);return function(e){const t=(0,d.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,s.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(i),(0,r.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(a.location.search);t.set(i,e),a.replace({...a.location,search:t.toString()})}),[i,a])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,i=p(e),[o,s]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[l,d]=h({queryString:n,groupId:a}),[c,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,i]=(0,u.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:a}),f=(()=>{const e=l??c;return m({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{f&&s(f)}),[f]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);s(e),d(e),g(e)}),[d,g,i]),tabValues:i}}var f=n(2389);const v="tabList__CuJ",b="tabItem_LNqP";function y(e){let{className:t,block:n,selectedValue:s,selectValue:l,tabValues:d}=e;const u=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.o5)(),p=e=>{const t=e.currentTarget,n=u.indexOf(t),a=d[n].value;a!==s&&(c(t),l(a))},m=e=>{var t;let n=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const t=u.indexOf(e.currentTarget)+1;n=u[t]??u[0];break}case"ArrowLeft":{const t=u.indexOf(e.currentTarget)-1;n=u[t]??u[u.length-1];break}}null==(t=n)||t.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},d.map((e=>{let{value:t,label:n,attributes:o}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>u.push(e),onKeyDown:m,onClick:p},o,{className:(0,i.Z)("tabs__item",b,null==o?void 0:o.className,{"tabs__item--active":s===t})}),n??t)})))}function k(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function w(e){const t=g(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",v)},r.createElement(y,(0,a.Z)({},e,t)),r.createElement(k,(0,a.Z)({},e,t)))}function R(e){const t=(0,f.Z)();return r.createElement(w,(0,a.Z)({key:String(t)},e))}},6470:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var a=n(7462),r=(n(7294),n(3905)),i=n(4866),o=n(5162);const s={title:"Pagination request strategy",sidebar_position:20},l=void 0,d={unversionedId:"strategy/usePagination",id:"strategy/usePagination",title:"Pagination request strategy",description:"Install",source:"@site/docs/07-strategy/02-usePagination.md",sourceDirName:"07-strategy",slug:"/strategy/usePagination",permalink:"/strategy/usePagination",draft:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/07-strategy/02-usePagination.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{title:"Pagination request strategy",sidebar_position:20},sidebar:"tutorialSidebar",previous:{title:"What more?",permalink:"/strategy/sensorless-data-interaction/what-more"},next:{title:"useIntervalRequest",permalink:"/strategy/useIntervalRequest"}},u={},c=[{value:"Install",id:"install",level:2},{value:"Features",id:"features",level:2},{value:"Example",id:"example",level:2},{value:"import",id:"import",level:2},{value:"usage",id:"usage",level:2},{value:"List operation function description",id:"list-operation-function-description",level:2},{value:"Insert list item",id:"insert-list-item",level:3},{value:"remove list item",id:"remove-list-item",level:3},{value:"update data item",id:"update-data-item",level:3},{value:"Refresh the data of the specified page",id:"refresh-the-data-of-the-specified-page",level:3},{value:"reset list",id:"reset-list",level:3},{value:"type",id:"type",level:2},{value:"limit",id:"limit",level:2}],p={toc:c};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"install"},"Install"),(0,r.kt)(i.Z,{groupId:"framework",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# npm\nnpm install @alova/scene-vue --save\n#yarn\nyarn add @alova/scene-vue\n\n"))),(0,r.kt)(o.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# npm\nnpm install @alova/scene-react --save\n#yarn\nyarn add @alova/scene-react\n\n"))),(0,r.kt)(o.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# npm\nnpm install @alova/scene-svelte --save\n#yarn\nyarn add @alova/scene-svelte\n\n")))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Before using extension hooks, make sure you are familiar with basic usage of alova.")),(0,r.kt)("p",null,"A hook designed for paging scenarios. You can use it in two paging scenarios: pull-down loading and page number flipping. ",(0,r.kt)("strong",{parentName:"p"},"This hook provides a wealth of features to help your application create better performance and more convenient paging functions "),"."),(0,r.kt)("h2",{id:"features"},"Features"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u2728 Rich and comprehensive paging status;"),(0,r.kt)("li",{parentName:"ul"},"\u2728 Rich and comprehensive pagination events;"),(0,r.kt)("li",{parentName:"ul"},"\u2728 Change page, pageSize to automatically get specified paging data;"),(0,r.kt)("li",{parentName:"ul"},"\u2728Data caching, no need to repeatedly request list data of the same parameters;"),(0,r.kt)("li",{parentName:"ul"},"\u2728 Front and back pages are preloaded, no waiting for page turning;"),(0,r.kt)("li",{parentName:"ul"},"\u2728Search condition monitoring automatically reacquires pages;"),(0,r.kt)("li",{parentName:"ul"},"\u2728 Support adding, editing and deleting list data;"),(0,r.kt)("li",{parentName:"ul"},"\u2728 Support refreshing the data of the specified page without reset;"),(0,r.kt)("li",{parentName:"ul"},"\u2728 Request-level search anti-shake, no need to maintain by yourself;")),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/example/paginated-list"},"Paginated list")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/example/load-more"},"Load more")),(0,r.kt)("h2",{id:"import"},"import"),(0,r.kt)(i.Z,{groupId:"framework",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import { usePagination } from '@alova/scene-vue';\n"))),(0,r.kt)(o.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import { usePagination } from '@alova/scene-react';\n"))),(0,r.kt)(o.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import { usePagination } from '@alova/scene-svelte';\n")))),(0,r.kt)("h2",{id:"usage"},"usage"),(0,r.kt)("p",null,"Display and operate the student list, take Vue as an example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import { ref, watchEffect } from 'vue';\nimport { queryStudents, removeStudent, editStudent } from './api.js';\nimport { usePagination } from '@alova/hooks/vue';\nimport { useRequest } from 'alova';\n\n// search condition status\nconst studentName = ref('');\nconst clsName = ref('');\n\nconst {\n  // load state\n  loading,\n\n  // list data\n  data,\n\n  // Is it the last page\n  // When pull-down loading, you can use this parameter to determine whether it needs to be loaded\n  isLastPage,\n\n  // The current page number, changing this page number will automatically trigger the request\n  page,\n\n  // number of data bars per page\n  pageSize,\n\n  // list item removal function\n  remove,\n\n  // list item insertion function\n  insert,\n\n  // Refresh function, you can specify to refresh a page of data\n  refresh,\n\n  // reset function, after calling it will clear the data and reload the first page\n  reload\n} = usePagination(\n  // Method instance get function, it will receive page and pageSize, and return a Method instance\n  (page, pageSize) => queryStudents(page, pageSize, studentName.value, clsName.value),\n  {\n    watchingStates: [studentName, clsName], // The state of external listening, such as search conditions\n    initialData: [], // initial data before request,\n    debounce: 300 // Debounce parameter, the unit is milliseconds, it can also be set as an array to set the debounce time separately for watchingStates\n    // append: true, // Whether to enable append mode, it needs to be set to true when drop-down loading, the default is false\n    // preloadPreviousPage: true, // Whether to preload the previous page data, the default is true\n    // preloadNextPage: true, // Whether to preload the next page data, the default is true\n    // total: data => data['total'], // Specify how to get the total value of the list item, data is the response data, and data.total is obtained by default\n    // data: data['data'], // Specify how to get the list data, data is the response data, and data.data is obtained by default\n    // initialPage: 1, // initial page number, default is 1\n    // initialPageSize: 10, // The initial number of data per page, the default is 10\n    // immediate: true // whether to send the request immediately, the default is true\n  }\n);\n\n// next page\nconst handleNextPage = () => {\n  page.value++;\n};\n\n// remove list item with silent commit\nconst { send: removeSend, onSuccess: onRemoveSuccess } = useRequest(id => removeStudent(id), {\n  immediate: false,\n  silent: true\n});\nonRemoveSuccess((_, removeId) => {\n  // Pass in the removed index item to remove the specified item\n  remove(students.value.findIndex(s => s.id === removeId));\n});\n\n// add or edit list item\nconst detail = ref({\n  name: '',\n  cls: ''\n});\nconst {\n  loading: submitting,\n  send: sendStudentEdit,\n  onSuccess\n} = useRequest(selectedId => editStudent(detail.value.name, detail.value.cls, selectedId), {\n  immediate: false,\n  silent: true\n});\nonSuccess((_, selectedId) => {\n  if (selectedId) {\n    // When editing, refresh the page where the updated list item is located, without resetting the list\n    const refreshPage = Math.floor(students.value.findIndex(({ id }) => id === selectedId) / pageSize.value) + 1;\n    refresh(refreshPage);\n  } else {\n    // When adding, reset the list\n    reload();\n  }\n});\n\n// Submit student information callback, selectedId has a value to indicate editing, otherwise it is new\nconst handleSubmit = selectedId => {\n  sendStudentEdit(selectedId);\n};\n")),(0,r.kt)("admonition",{title:"debounce description",type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"The debounce parameter can be set as an array, and the debounce time is set separately for changes in the monitoring state (watchingStates), which is achieved through the request debounce in ",(0,r.kt)("a",{parentName:"p",href:"/request-timing/use-watcher"},(0,r.kt)("strong",{parentName:"a"},"useWatcher")),". ",(0,r.kt)("strong",{parentName:"p"},"At the end of the monitoring state, there are two hidden monitoring states of page and pageSize, which can also be set by debounce. "))),(0,r.kt)("h2",{id:"list-operation-function-description"},"List operation function description"),(0,r.kt)("p",null,"usePagination provides a full-featured list manipulation function, which can achieve the same effect as re-requesting the list without re-requesting the list, which greatly improves the interactive experience of the page. Continue to read the specific function description below!"),(0,r.kt)("h3",{id:"insert-list-item"},"Insert list item"),(0,r.kt)("p",null,"You can use it to insert a list item to any position in the list, it will remove the last item after inserting, to ensure the same effect as re-requesting the current page data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Insert a piece of data, if no index is passed in, it will be inserted to the front by default\n * @param item Insert item\n * @param index Insertion position (index)\n */\ninsert: (item: LD[number], index?: number) => void;\n")),(0,r.kt)("p",null,"The following is an example of returning to the first page and inserting a list item in ",(0,r.kt)("strong",{parentName:"p"},"non-append mode")," (page number page turning scene):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"page.value = 1;\nnextTick(() => {\n  insert(newItem, 0);\n});\n")),(0,r.kt)("p",null,"The following is an example of scrolling to the top after inserting a list item in ",(0,r.kt)("strong",{parentName:"p"},"append mode")," (drop-down loading scene):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"insert(newItem, 0);\nnextTick(() => {\n  window.scrollTo(0, {});\n});\n")),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"onBefore, insert operation, onAfter are all executed asynchronously in series, so if the state is changed in ",(0,r.kt)("inlineCode",{parentName:"p"},"onBefore"),", the view will be refreshed and then the insert operation will be performed.")),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"In order for the data to be correct, the insert function call clears the entire cache.")),(0,r.kt)("h3",{id:"remove-list-item"},"remove list item"),(0,r.kt)("p",null,"In the case where there is a cache on the next page, it will use the cache of the next page to add to the end of the list item after removing an item to ensure the same effect as re-requesting the current page data. In ",(0,r.kt)("strong",{parentName:"p"},"append mode")," and ",(0,r.kt)("strong",{parentName:"p"},"Non-append mode")," behaves the same."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * remove a piece of data\n * @param index the index to remove\n */\nremove: (index: number) => void;\n")),(0,r.kt)("p",null,"But in the following two cases, it will re-initiate the request to refresh the data of the corresponding page:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The next page is not cached"),(0,r.kt)("li",{parentName:"ol"},"The data that exceeds the cached list items on the next page is continuously called synchronously, and the cached data is not enough to be added to the current page list.")),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"In order to make the data correct, the remove function call will clear the entire cache.")),(0,r.kt)("h3",{id:"update-data-item"},"update data item"),(0,r.kt)("p",null,"Use this function when you want to update a list item."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * replace a piece of data\n * @param item replacement\n * @param index replacement position (index)\n */\nreplace: (item: LD[number], index: number) => void;\n")),(0,r.kt)("h3",{id:"refresh-the-data-of-the-specified-page"},"Refresh the data of the specified page"),(0,r.kt)("p",null,"When you do not want to update the list items locally after the data operation, but re-request data from the server, you can use refresh to refresh the data of any page without resetting the list data and letting the user start browsing from the first page again."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Refresh the specified page number data, this function will ignore the cache and force the request to be sent\n * @param refreshPage refresh page number\n */\nrefresh: (refreshPage: number) => void;\n")),(0,r.kt)("h3",{id:"reset-list"},"reset list"),(0,r.kt)("p",null,"It will clear the entire cache and reload the first page."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Reload the list from the first page and clear the cache\n */\nreload: () => void;\n")),(0,r.kt)("h2",{id:"type"},"type"),(0,r.kt)(i.Z,{groupId:"framework",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface UsePaginationReturnType<LD extends any[], R> {\n  loading: Ref<boolean>;\n  error: Ref<Error | undefined>;\n  downloading: Ref<Progress>;\n  uploading: Ref<Progress>;\n  page: Ref<number>;\n  pageSize: Ref<number>;\n  data: Ref<LD>;\n  pageCount: ComputedRef<number | undefined>;\n  total: ComputedRef<number | undefined>;\n  isLastPage: ComputedRef<boolean>;\n\n  abort: () => void;\n  send: (...args: any[]) => Promise<R>;\n  onSuccess: (handler: SuccessHandler<R>) => void;\n  onError: (handler: ErrorHandler) => void;\n  onComplete: (handler: CompleteHandler) => void;\n\n  fetching: Ref<boolean>;\n  onFetchSuccess: (handler: SuccessHandler<R>) => void;\n  onFetchError: (handler: ErrorHandler) => void;\n  onFetchComplete: (handler: CompleteHandler) => void;\n\n  /**\n   * Refresh the specified page number data, this function will ignore the cache and force the request to be sent\n   * @param refreshPage refresh page number\n   */\n  refresh: (refreshPage: number) => void;\n\n  /**\n   * insert a piece of data\n   * onBefore, insert operation, onAfter all need to be executed asynchronously in sequence, because you need to wait for the view to update before executing\n   * @param item Insert item\n   * @param config insert configuration\n   */\n  insert: (item: LD[number], config?: InsertConfig) => void;\n\n  /**\n   * remove a piece of data\n   * @param index the index to remove\n   */\n  remove: (index: any) => void;\n\n  /**\n   * Reload the list from the first page and clear the cache\n   */\n  reload: () => void;\n}\n\n/**\n * vue paging hook based on alova.js\n * Automatic management of paging related status, preloading of previous and previous pages, automatic maintenance of data addition/editing/replacement/removal\n *\n * @param handler method creation function\n * @param config pagination hook configuration\n * @returns {UsePaginationReturnType}\n */\nexport declare function usePagination<\n  S extends Ref,\n  E extends Ref,\n  R,\n  T,\n  RC,\n  RE,\n  RH,\n  LD extends any[],\n  WS extends WatchSource[]\n>(\n  handler: (page: number, pageSize: number) => Method<S, E, R, T, RC, RE, RH>,\n  config: PaginationConfig<R, LD, WS>\n): UsePaginationReturnType<LD, R>;\n"))),(0,r.kt)(o.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type ReactState<S> = [S, Dispatch<SetStateAction<S>>];\ninterface UsePaginationReturnType<LD extends any[], R> {\n  loading: boolean;\n  error: Error | undefined;\n  downloading: Progress;\n  uploading: Progress;\n  page: ReactState<number>;\n  pageSize: ReactState<number>;\n  data: LD;\n  pageCount: number | undefined;\n  total: number | undefined;\n  isLastPage: boolean;\n\n  abort: () => void;\n  send: (...args: any[]) => Promise<R>;\n  onSuccess: (handler: SuccessHandler<R>) => void;\n  onError: (handler: ErrorHandler) => void;\n  onComplete: (handler: CompleteHandler) => void;\n\n  fetching: boolean;\n  onFetchSuccess: (handler: SuccessHandler<R>) => void;\n  onFetchError: (handler: ErrorHandler) => void;\n  onFetchComplete: (handler: CompleteHandler) => void;\n\n  /**\n   * Refresh the specified page number data, this function will ignore the cache and force the request to be sent\n   * @param refreshPage refresh page number\n   */\n  refresh: (refreshPage: number) => void;\n\n  /**\n   * insert a piece of data\n   * onBefore, insert operation, onAfter all need to be executed asynchronously in sequence, because you need to wait for the view to update before executing\n   * @param item Insert item\n   * @param config insert configuration\n   */\n  insert: (item: LD[number], config?: InsertConfig) => void;\n\n  /**\n   * remove a piece of data\n   * @param index the index to remove\n   */\n  remove: (index: any) => void;\n\n  /**\n   * Reload the list from the first page and clear the cache\n   */\n  reload: () => void;\n}\n\n/**\n * React paging hook based on alova.js\n * Automatic management of paging related status, preloading of previous and previous pages, automatic maintenance of data addition/editing/removal\n *\n * @param handler method creation function\n * @param config pagination hook configuration\n * @returns {UsePaginationReturnType}\n */\nexport declare function usePagination<S, E, R, T, RC, RE, RH, LD extends any[], WS extends DependencyList>(\n  handler: (page: number, pageSize: number) => Method<S, E, R, T, RC, RE, RH>,\n  config: PaginationConfig<R, LD, WS>\n): UsePaginationReturnType<LD, R>;\n"))),(0,r.kt)(o.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface UsePaginationReturnType<LD extends any[], R> {\n  loading: Writable<boolean>;\n  error: Writable<Error | undefined>;\n  downloading: Writable<Progress>;\n  uploading: Writable<Progress>;\n  page: Writable<number>;\n  pageSize: Writable<number>;\n  data: Writable<LD>;\n  pageCount: Readable<number | undefined>;\n  total: Readable<number | undefined>;\n  isLastPage: Readonly<Readable<boolean>>;\n\n  abort: () => void;\n  send: (...args: any[]) => Promise<R>;\n  onSuccess: (handler: SuccessHandler<R>) => void;\n  onError: (handler: ErrorHandler) => void;\n  onComplete: (handler: CompleteHandler) => void;\n\n  fetching: Writable<boolean>;\n  onFetchSuccess: (handler: SuccessHandler<R>) => void;\n  onFetchError: (handler: ErrorHandler) => void;\n  onFetchComplete: (handler: CompleteHandler) => void;\n\n  /**\n   * Refresh the specified page number data, this function will ignore the cache and force the request to be sent\n   * @param refreshPage refresh page number\n   */\n  refresh: (refreshPage: number) => void;\n\n  /**\n   * insert a piece of data\n   * onBefore, insert operation, onAfter all need to be executed asynchronously in sequence, because you need to wait for the view to update before executing\n   * @param item Insert item\n   * @param config insert configuration\n   */\n  insert: (item: LD[number], config?: InsertConfig) => void;\n\n  /**\n   * remove a piece of data\n   * @param index the index to remove\n   */\n  remove: (index: any) => void;\n\n  /**\n   * Reload the list from the first page and clear the cache\n   */\n  reload: () => void;\n}\n\n/**\n * svelte paging hook based on alova.js\n * Automatic management of paging related status, preloading of previous and previous pages, automatic maintenance of data addition/editing/removal\n *\n * @param handler method creation function\n * @param config pagination hook configuration\n * @returns {UsePaginationReturnType}\n */\nexport declare function usePagination<\n  S extends Writable<any>,\n  E extends Writable<any>,\n  R,\n  T,\n  RC,\n  RE,\n  RH,\n  LD extends any[],\n  WS extends Readable<any>[]\n>(\n  handler: (page: number, pageSize: number) => Method<S, E, R, T, RC, RE, RH>,\n  config: PaginationConfig<R, LD, WS>\n): UsePaginationReturnType<LD, R>;\n")))),(0,r.kt)("h2",{id:"limit"},"limit"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Placeholder Mode")," and ",(0,r.kt)("strong",{parentName:"li"},"Restore Mode")," are temporarily disabled.")))}m.isMDXComponent=!0}}]);