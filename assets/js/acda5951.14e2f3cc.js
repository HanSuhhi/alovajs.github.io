"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[8682],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>v});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=d(a),v=r,h=p["".concat(s,".").concat(v)]||p[v]||c[v]||i;return a?n.createElement(h,l(l({ref:t},u),{},{components:a})):n.createElement(h,l({ref:t},u))}));function v(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=p;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=a[d];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},4850:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var n=a(7462),r=(a(7294),a(3905));const i={title:"Virtual data",sidebar_position:20},l=void 0,o={unversionedId:"strategy/sensorless-data-interaction/virtual-data",id:"strategy/sensorless-data-interaction/virtual-data",title:"Virtual data",description:"In fact, virtual data is a reference object with a unique id, and its tracking mechanism is realized by first generating a mapping between virtual data id and response data, and then finding and replacing it with the actual value through virtual data id.",source:"@site/docs/07-strategy/01-sensorless-data-interaction/02-virtual-data.md",sourceDirName:"07-strategy/01-sensorless-data-interaction",slug:"/strategy/sensorless-data-interaction/virtual-data",permalink:"/strategy/sensorless-data-interaction/virtual-data",draft:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/07-strategy/01-sensorless-data-interaction/02-virtual-data.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{title:"Virtual data",sidebar_position:20},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/strategy/sensorless-data-interaction/overview"},next:{title:"Boot silent factory",permalink:"/strategy/sensorless-data-interaction/start-silent-factory"}},s={},d=[{value:"string concatenation",id:"string-concatenation",level:2},{value:"Data Comparison",id:"data-comparison",level:2},{value:"Participate in operations",id:"participate-in-operations",level:2},{value:"type operator",id:"type-operator",level:2},{value:"View display",id:"view-display",level:2},{value:"virtual data helper functions",id:"virtual-data-helper-functions",level:2},{value:"dehydrateVData",id:"dehydratevdata",level:3},{value:"stringifyVData",id:"stringifyvdata",level:3},{value:"equals",id:"equals",level:3},{value:"Replacement restrictions for virtual data",id:"replacement-restrictions-for-virtual-data",level:2},{value:"Next",id:"next",level:2}],u={toc:d};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In fact, virtual data is a reference object with a unique id, and its tracking mechanism is realized by first generating a mapping between virtual data id and response data, and then finding and replacing it with the actual value through virtual data id."),(0,r.kt)("p",null,"When the original value is a reference type, the performance is the same as the original value, but the virtual data of the basic type uses ",(0,r.kt)("inlineCode",{parentName:"p"},"Number, String, Boolean")," encapsulation classes, as well as custom ",(0,r.kt)("inlineCode",{parentName:"p"},"Undefined, Null")," encapsulation classes, and their expressions are the same as There are some deviations from the original value. The characteristics of the virtual data and the use of auxiliary functions for the virtual data are listed below. The details of the auxiliary functions will be introduced at the end of the chapter."),(0,r.kt)("h2",{id:"string-concatenation"},"string concatenation"),(0,r.kt)("p",null,"When virtual data is concatenated, it will be converted to virtual data id for splicing."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const virtualData = createVirtualData(1);\n'a' + virtualData; // a[vd:xxxxxx]\n1 + virtualData; // 1[vd:xxxxxx]\n")),(0,r.kt)("h2",{id:"data-comparison"},"Data Comparison"),(0,r.kt)("p",null,"Virtual data cannot be directly used for comparison, but virtual data and actual data are often mixed and compared in actual scenarios. In this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"equals")," can be used for comparison."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import { equals } from '@alova/scene-*';\n\nequals('a', 'a'); // true\n\nconst virtualData1 = createVirtualData(1);\nconst virtualData2 = virtualData1.clone(); // clone virtual data\nequals(virtualData1, virtualData2); // true when the ids of virtualData1 and virtualData2 are the same\nequals(virtualData1, '[vd:xxxxxx]'); // true when the id of virtualData1 is also [vd:xxxxxx]\n")),(0,r.kt)("h2",{id:"participate-in-operations"},"Participate in operations"),(0,r.kt)("p",null,"When participating in operations such as ",(0,r.kt)("inlineCode",{parentName:"p"},"+-*/%"),", numerical comparison, and bit operations, it cannot be automatically converted to the original value. It can be converted to the original value through ",(0,r.kt)("inlineCode",{parentName:"p"},"dehydrateVData")," and then calculated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import { dehydrateVData } from '@alova/scene-*';\n\nconst virtualData = createVirtualData(1);\ndehydrateVData(virtualData) + 1; // 2\ndehydrateVData(virtualData) > 0; // true\n")),(0,r.kt)("h2",{id:"type-operator"},"type operator"),(0,r.kt)("p",null,"Because the virtual data is implemented using the encapsulation class on the basic data type, ",(0,r.kt)("inlineCode",{parentName:"p"},"object")," will always be returned when using ",(0,r.kt)("inlineCode",{parentName:"p"},"typeof")," to get the type, and it can also be converted to the original value by ",(0,r.kt)("inlineCode",{parentName:"p"},"dehydrateVData")," to get the type"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const vNum = createVirtualResponse(1);\ntypeof vNum === 'object'; // true\nconst vUndef = createVirtualResponse(undefined);\ntypeof vUndef === 'object'; // true\n\ntypeof dehydrateVData(vNum) === 'number'; // true\ntypeof dehydrateVData(vUndef) === 'undefined'; // true\n")),(0,r.kt)("p",null,"To solve this problem, you can use the virtual data helper function ",(0,r.kt)("strong",{parentName:"p"},"dehydrateVData"),", which can get the original value of a virtual data, and return it unchanged when encountering non-virtual data"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const vNum = createVirtualResponse(1);\ntypeof dehydrateVData(vNum) === 'number'; // true\ndehydrateVData(vNum) === 1; // true\ndehydrateVData('string') === 'string'; // true\n")),(0,r.kt)("h2",{id:"view-display"},"View display"),(0,r.kt)("p",null,"By default, ",(0,r.kt)("inlineCode",{parentName:"p"},"toString")," will be called implicitly when the virtual data is displayed in the view, but sometimes you will encounter problems with display confusion, and rendering an object in ",(0,r.kt)("strong",{parentName:"p"},"react")," will report the following error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Uncaught Error: Objects are not valid as a React child (found: object with keys {}). If you meant to render a collection of children, use an array instead.\n")),(0,r.kt)("p",null,"Therefore, it is recommended to use ",(0,r.kt)("inlineCode",{parentName:"p"},"dehydrateVData")," to convert to raw data for display."),(0,r.kt)("h2",{id:"virtual-data-helper-functions"},"virtual data helper functions"),(0,r.kt)("h3",{id:"dehydratevdata"},"dehydrateVData"),(0,r.kt)("p",null,"Dehydrate virtual data and return its original value, if target is non-virtual data, return it as it is."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// type\nfunction dehydrateVData(target: any): any;\n\n// example\ndehydrateVData(1); // 1\nconst virtualData = createVirtualData(1);\ndehydrateVData(virtualData); // 1\n")),(0,r.kt)("h3",{id:"stringifyvdata"},"stringifyVData"),(0,r.kt)("p",null,"Stringify virtual data, return virtual data id, when returnOriginalIfNotVData is set to false, non-virtual data will be returned as-is."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// type\nfunction stringifyVData(target: any, returnOriginalIfNotVData?: boolean): any;\n\n// example\nstringifyVData(1); // 1\nstringifyVData(1, false); // undefined\n\nconst virtualData = createVirtualData(1);\nstringifyVData(virtualData); // [vd:xxxxxx]\n")),(0,r.kt)("h3",{id:"equals"},"equals"),(0,r.kt)("p",null,"Judge whether two values are equal in a way that is compatible with virtual data. When there is no virtual data to participate in the comparison, it will be strictly compared. Otherwise, it will be compared whether the virtual data id is the same. If there may be virtual data involved in the comparison data, it is recommended to use this function for comparison."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// type\nfunction equals(prevValue: any, nextValue: any): boolean;\n\n// example\nequals('a', 'a'); // true\nconst virtualData1 = createVirtualData(1);\nconst virtualData2 = virtualData1.clone(); // clone virtual data\nequals(virtualData1, virtualData2); // true when the ids of virtualData1 and virtualData2 are the same\nequals(virtualData1, '[vd:xxxxxx]'); // true when the id of virtualData1 is also [vd:xxxxxx]\n")),(0,r.kt)("p",null,"###isVData"),(0,r.kt)("p",null,"Determine whether the target data is virtual data"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// type\nfunction isVData(target: any): boolean;\n\n// example\nisVData(1); // false\nconst virtualData = createVirtualData(1);\nisVData(virtualData); // true\nisVData('[vd:xxxxxx]'); //true\n")),(0,r.kt)("h2",{id:"replacement-restrictions-for-virtual-data"},"Replacement restrictions for virtual data"),(0,r.kt)("p",null,"The tracing mechanism of virtual data can only deeply traverse relevant data, and then replace the data with virtual data identifiers with actual data. If some data is generated by virtual data, it will not be recalculated after virtual data is replaced with actual data."),(0,r.kt)("p",null,"In the following cases, even if the virtualId is replaced with actual data, the id of the request will not be recalculated. Therefore, if replacement is required, the virtualId must be directly used as a request parameter. The example is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const deleteTodo = virtualId => {\n  return alova.Delete('/deleteTodo', {\n    id: dehydrateVData(virtualId) === null ? 1 : 2\n  });\n};\n")),(0,r.kt)("p",null,"But if virtual data is concatenated as string, it will be automatically converted to virtual data id to participate in string concatenation, which will work. In the following cases, the value of the request id at the beginning is ",(0,r.kt)("inlineCode",{parentName:"p"},"id_[vd:xxxxxx]"),", and when virtualId is replaced with the response value (assuming it is replaced with 1), it will be automatically updated to ",(0,r.kt)("inlineCode",{parentName:"p"},"id_1"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const deleteTodo = virtualId => {\n   return alova. Delete('/deleteTodo', {\n     id: 'id'_virtualId\n   });\n};\n")),(0,r.kt)("h2",{id:"next"},"Next"),(0,r.kt)("p",null,"Although it is simple enough to realize non-inductive interaction, there are still some additional processing compared with conservative requests. The specific implementation is roughly divided into the following steps."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Implement functions in a conservative request manner;"),(0,r.kt)("li",{parentName:"ol"},"Manually update the list data to realize localized data compensation;"),(0,r.kt)("li",{parentName:"ol"},"Record data operations so that you can manually add to the latest records when there are unsubmitted modifications;"),(0,r.kt)("li",{parentName:"ol"},"Manually compensate the unsubmitted data to the list, so that the latest status can be displayed even if the data is not submitted;"),(0,r.kt)("li",{parentName:"ol"},"When modifying unsubmitted data, intercept requests with virtual data;")),(0,r.kt)("p",null,"Next, we will demonstrate with a simple example."))}c.isMDXComponent=!0}}]);