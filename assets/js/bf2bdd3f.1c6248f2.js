"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[1087],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),d=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=d(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(t),m=i,h=c["".concat(l,".").concat(m)]||c[m]||p[m]||r;return t?a.createElement(h,o(o({ref:n},u),{},{components:t})):a.createElement(h,o({ref:n},u))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=c;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var d=2;d<r;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>o});var a=t(7294),i=t(6010);const r="tabItem_Ymn6";function o(e){let{children:n,hidden:t,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,o),hidden:t},n)}},5488:(e,n,t)=>{t.d(n,{Z:()=>m});var a=t(7462),i=t(7294),r=t(6010),o=t(2389),s=t(7392),l=t(7094),d=t(2466);const u="tabList__CuJ",p="tabItem_LNqP";function c(e){var n;const{lazy:t,block:o,defaultValue:c,values:m,groupId:h,className:g}=e,f=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),v=m??f.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),b=(0,s.l)(v,((e,n)=>e.value===n.value));if(b.length>0)throw new Error(`Docusaurus error: Duplicate values "${b.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const y=null===c?c:c??(null==(n=f.find((e=>e.props.default)))?void 0:n.props.value)??f[0].props.value;if(null!==y&&!v.some((e=>e.value===y)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${y}" but none of its children has the corresponding value. Available values are: ${v.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:w}=(0,l.U)(),[x,R]=(0,i.useState)(y),N=[],{blockElementScrollPositionUntilNextRender:S}=(0,d.o5)();if(null!=h){const e=k[h];null!=e&&e!==x&&v.some((n=>n.value===e))&&R(e)}const P=e=>{const n=e.currentTarget,t=N.indexOf(n),a=v[t].value;a!==x&&(S(n),R(a),null!=h&&w(h,String(a)))},T=e=>{var n;let t=null;switch(e.key){case"Enter":P(e);break;case"ArrowRight":{const n=N.indexOf(e.currentTarget)+1;t=N[n]??N[0];break}case"ArrowLeft":{const n=N.indexOf(e.currentTarget)-1;t=N[n]??N[N.length-1];break}}null==(n=t)||n.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",u)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":o},g)},v.map((e=>{let{value:n,label:t,attributes:o}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:x===n?0:-1,"aria-selected":x===n,key:n,ref:e=>N.push(e),onKeyDown:T,onClick:P},o,{className:(0,r.Z)("tabs__item",p,null==o?void 0:o.className,{"tabs__item--active":x===n})}),t??n)}))),t?(0,i.cloneElement)(f.filter((e=>e.props.value===x))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},f.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==x})))))}function m(e){const n=(0,o.Z)();return i.createElement(c,(0,a.Z)({key:String(n)},e))}},2307:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>d,toc:()=>p});var a=t(7462),i=(t(7294),t(3905)),r=t(5488),o=t(5162);const s={title:"usePagination",sidebar_position:20},l=void 0,d={unversionedId:"extension/alova-hooks/usePagination",id:"extension/alova-hooks/usePagination",title:"usePagination",description:"Install",source:"@site/docs/09-extension/02-alova-hooks/01-usePagination.md",sourceDirName:"09-extension/02-alova-hooks",slug:"/extension/alova-hooks/usePagination",permalink:"/extension/alova-hooks/usePagination",draft:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/09-extension/02-alova-hooks/01-usePagination.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{title:"usePagination",sidebar_position:20},sidebar:"tutorialSidebar",previous:{title:"extend hooks",permalink:"/category/extend-hooks"},next:{title:"useIntervalRequest",permalink:"/extension/alova-hooks/useIntervalRequest"}},u={},p=[{value:"Install",id:"install",level:2},{value:"Features",id:"features",level:2},{value:"example",id:"example",level:2},{value:"import",id:"import",level:2},{value:"usage",id:"usage",level:2},{value:"List operation function description",id:"list-operation-function-description",level:2},{value:"Insert list item",id:"insert-list-item",level:3},{value:"remove list item",id:"remove-list-item",level:3},{value:"update data item",id:"update-data-item",level:3},{value:"Refresh the data of the specified page",id:"refresh-the-data-of-the-specified-page",level:3},{value:"reset list",id:"reset-list",level:3},{value:"type",id:"type",level:2},{value:"limit",id:"limit",level:2}],c={toc:p};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"install"},"Install"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"1",label:"npm",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm install @alova/hooks --save\n"))),(0,i.kt)(o.Z,{value:"2",label:"yarn",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add @alova/hooks\n")))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Before using extension hooks, make sure you are familiar with the basic use of alova.")),(0,i.kt)("p",null,"The hook designed for paging scenarios, you can use it in two paging scenarios: drop-down loading and page number flipping. ",(0,i.kt)("strong",{parentName:"p"},"This hook provides rich features to help your application create better performance and use more convenient paging functions "),"."),(0,i.kt)("h2",{id:"features"},"Features"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u2728 Rich and comprehensive paging status;"),(0,i.kt)("li",{parentName:"ul"},"\u2728 Rich and comprehensive paging events;"),(0,i.kt)("li",{parentName:"ul"},"\u2728Change page and pageSize to automatically obtain the specified paging data;"),(0,i.kt)("li",{parentName:"ul"},"\u2728Data cache, no need to repeatedly request list data with the same parameters;"),(0,i.kt)("li",{parentName:"ul"},"\u2728Front and back pages are preloaded, no more waiting for page turning;"),(0,i.kt)("li",{parentName:"ul"},"\u2728Search condition monitoring automatically re-acquires the number of pages;"),(0,i.kt)("li",{parentName:"ul"},"\u2728Support adding, editing and deleting list data;"),(0,i.kt)("li",{parentName:"ul"},"\u2728Support to refresh the data of the specified page, no need to reset;"),(0,i.kt)("li",{parentName:"ul"},"\u2728Request-level search stabilization without self-maintenance;")),(0,i.kt)("h2",{id:"example"},"example"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"../../example/paginated-list"},"page number list")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"../../example/load-more"},"pull down to load more")),(0,i.kt)("h2",{id:"import"},"import"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { usePagination } from '@alova/hooks/vue';\n"))),(0,i.kt)(o.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { usePagination } from '@alova/hooks/react';\n"))),(0,i.kt)(o.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { usePagination } from '@alova/hooks/svelte';\n")))),(0,i.kt)("h2",{id:"usage"},"usage"),(0,i.kt)("p",null,"Display and operate the student list, take Vue as an example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { ref, watchEffect } from 'vue';\nimport { queryStudents, removeStudent, editStudent } from './api.js';\nimport { usePagination } from '@alova/hooks/vue';\nimport { useRequest } from 'alova';\n\n// search condition status\nconst studentName = ref('');\nconst clsName = ref('');\n\nconst {\n  // load state\n  loading,\n\n  // list data\n  data,\n\n  // Is it the last page\n  // When pull-down loading, you can use this parameter to determine whether it needs to be loaded\n  isLastPage,\n\n  // The current page number, changing this page number will automatically trigger the request\n  page,\n\n  // number of data bars per page\n  pageSize,\n\n  // list item removal function\n  remove,\n\n  // list item insertion function\n  insert,\n\n  // Refresh function, you can specify to refresh a page of data\n  refresh,\n\n  // reset function, after calling it will clear the data and reload the first page\n  reload\n} = usePagination(\n  // Method instance get function, it will receive page and pageSize, and return a Method instance\n  (page, pageSize) => queryStudents(page, pageSize, studentName.value, clsName.value),\n  {\n    watchingStates: [studentName, clsName], // The state of external listening, such as search conditions\n    initialData: [], // initial data before request,\n    debounce: 300 // Debounce parameter, the unit is milliseconds, it can also be set as an array to set the debounce time separately for watchingStates\n    // append: true, // Whether to enable append mode, it needs to be set to true when drop-down loading, the default is false\n    // preloadPreviousPage: true, // Whether to preload the previous page data, the default is true\n    // preloadNextPage: true, // Whether to preload the next page data, the default is true\n    // total: data => data['total'], // Specify how to get the total value of the list item, data is the response data, and data.total is obtained by default\n    // data: data['data'], // Specify how to get the list data, data is the response data, and data.data is obtained by default\n    // initialPage: 1, // initial page number, default is 1\n    // initialPageSize: 10, // The initial number of data per page, the default is 10\n    // immediate: true // whether to send the request immediately, the default is true\n  }\n);\n\n// next page\nconst handleNextPage = () => {\n  page.value++;\n};\n\n// remove list item with silent commit\nconst { send: removeSend, onSuccess: onRemoveSuccess } = useRequest(id => removeStudent(id), {\n  immediate: false,\n  silent: true\n});\nonRemoveSuccess((_, removeId) => {\n  // Pass in the removed index item to remove the specified item\n  remove(students.value.findIndex(s => s.id === removeId));\n});\n\n// add or edit list item\nconst detail = ref({\n  name: '',\n  cls: ''\n});\nconst {\n  loading: submitting,\n  send: sendStudentEdit,\n  onSuccess\n} = useRequest(selectedId => editStudent(detail.value.name, detail.value.cls, selectedId), {\n  immediate: false,\n  silent: true\n});\nonSuccess((_, selectedId) => {\n  if (selectedId) {\n    // When editing, refresh the page where the updated list item is located, without resetting the list\n    const refreshPage = Math.floor(students.value.findIndex(({ id }) => id === selectedId) / pageSize.value) + 1;\n    refresh(refreshPage);\n  } else {\n    // When adding, reset the list\n    reload();\n  }\n});\n\n// Submit student information callback, selectedId has a value to indicate editing, otherwise it is new\nconst handleSubmit = selectedId => {\n  sendStudentEdit(selectedId);\n};\n")),(0,i.kt)("admonition",{title:"debounce parameter description",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"The debounce parameter can be set as an array, and the debounce time can be set separately for the change of the monitoring state (watchingStates). realized. ",(0,i.kt)("strong",{parentName:"p"},"At the end of the listening state, there are two hidden listening states, page and pageSize, which can also be set by debounce. "))),(0,i.kt)("h2",{id:"list-operation-function-description"},"List operation function description"),(0,i.kt)("p",null,"usePagination provides a full-featured list manipulation function, which can achieve the same effect as re-requesting the list without re-requesting the list, which greatly improves the interactive experience of the page. Continue to read the specific function description below!"),(0,i.kt)("h3",{id:"insert-list-item"},"Insert list item"),(0,i.kt)("p",null,"You can use it to insert a list item to any position in the list, it will remove the last item after inserting, to ensure the same effect as re-requesting the current page data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Insert a piece of data, if no index is passed in, it will be inserted to the front by default\n * @param item Insert item\n * @param index Insertion position (index)\n */\ninsert: (item: LD[number], index?: number) => void;\n")),(0,i.kt)("p",null,"The following is an example of returning to the first page and inserting a list item in ",(0,i.kt)("strong",{parentName:"p"},"non-append mode")," (page number page turning scene):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"page.value = 1;\nnextTick(() => {\n  insert(newItem, 0);\n});\n")),(0,i.kt)("p",null,"The following is an example of scrolling to the top after inserting a list item in ",(0,i.kt)("strong",{parentName:"p"},"append mode")," (drop-down loading scene):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"insert(newItem, 0);\nnextTick(() => {\n  window.scrollTo(0, {});\n});\n")),(0,i.kt)("admonition",{title:"note",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"onBefore, insert operation, onAfter are all executed asynchronously in series, so if the state is changed in ",(0,i.kt)("inlineCode",{parentName:"p"},"onBefore"),", the view will be refreshed and then the insert operation will be performed.")),(0,i.kt)("admonition",{title:"note",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"In order for the data to be correct, the insert function call clears the entire cache.")),(0,i.kt)("h3",{id:"remove-list-item"},"remove list item"),(0,i.kt)("p",null,"In the case where there is a cache on the next page, it will use the cache of the next page to add to the end of the list item after removing an item to ensure the same effect as re-requesting the current page data. In ",(0,i.kt)("strong",{parentName:"p"},"append mode")," and ",(0,i.kt)("strong",{parentName:"p"},"Non-append mode")," behaves the same."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * remove a piece of data\n * @param index the index to remove\n */\nremove: (index: number) => void;\n")),(0,i.kt)("p",null,"But in the following two cases, it will re-initiate the request to refresh the data of the corresponding page:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The next page is not cached"),(0,i.kt)("li",{parentName:"ol"},"The data that exceeds the cached list items on the next page is continuously called synchronously, and the cached data is not enough to be added to the current page list.")),(0,i.kt)("admonition",{title:"note",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"In order to make the data correct, the remove function call will clear the entire cache.")),(0,i.kt)("h3",{id:"update-data-item"},"update data item"),(0,i.kt)("p",null,"Use this function when you want to update a list item."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * replace a piece of data\n * @param item replacement\n * @param index replacement position (index)\n */\nreplace: (item: LD[number], index: number) => void;\n")),(0,i.kt)("h3",{id:"refresh-the-data-of-the-specified-page"},"Refresh the data of the specified page"),(0,i.kt)("p",null,"When you do not want to update the list items locally after the data operation, but re-request data from the server, you can use refresh to refresh the data of any page without resetting the list data and letting the user start browsing from the first page again."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Refresh the specified page number data, this function will ignore the cache and force the request to be sent\n * @param refreshPage refresh page number\n */\nrefresh: (refreshPage: number) => void;\n")),(0,i.kt)("h3",{id:"reset-list"},"reset list"),(0,i.kt)("p",null,"It will clear the entire cache and reload the first page."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Reload the list from the first page and clear the cache\n */\nreload: () => void;\n")),(0,i.kt)("h2",{id:"type"},"type"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface UsePaginationReturnType<LD extends any[], R> {\n  loading: Ref<boolean>;\n  error: Ref<Error | undefined>;\n  downloading: Ref<Progress>;\n  uploading: Ref<Progress>;\n  page: Ref<number>;\n  pageSize: Ref<number>;\n  data: Ref<LD>;\n  pageCount: ComputedRef<number | undefined>;\n  total: ComputedRef<number | undefined>;\n  isLastPage: ComputedRef<boolean>;\n\n  abort: () => void;\n  send: (...args: any[]) => Promise<R>;\n  onSuccess: (handler: SuccessHandler<R>) => void;\n  onError: (handler: ErrorHandler) => void;\n  onComplete: (handler: CompleteHandler) => void;\n\n  fetching: Ref<boolean>;\n  onFetchSuccess: (handler: SuccessHandler<R>) => void;\n  onFetchError: (handler: ErrorHandler) => void;\n  onFetchComplete: (handler: CompleteHandler) => void;\n\n  /**\n   * Refresh the specified page number data, this function will ignore the cache and force the request to be sent\n   * @param refreshPage refresh page number\n   */\n  refresh: (refreshPage: number) => void;\n\n  /**\n   * insert a piece of data\n   * onBefore, insert operation, onAfter all need to be executed asynchronously in sequence, because you need to wait for the view to update before executing\n   * @param item Insert item\n   * @param config insert configuration\n   */\n  insert: (item: LD[number], config?: InsertConfig) => void;\n\n  /**\n   * remove a piece of data\n   * @param index the index to remove\n   */\n  remove: (index: any) => void;\n\n  /**\n   * Reload the list from the first page and clear the cache\n   */\n  reload: () => void;\n}\n\n/**\n * vue paging hook based on alova.js\n * Automatic management of paging related status, preloading of previous and previous pages, automatic maintenance of data addition/editing/replacement/removal\n *\n * @param handler method creation function\n * @param config pagination hook configuration\n * @returns {UsePaginationReturnType}\n */\nexport declare function usePagination<\n  S extends Ref,\n  E extends Ref,\n  R,\n  T,\n  RC,\n  RE,\n  RH,\n  LD extends any[],\n  WS extends WatchSource[]\n>(\n  handler: (page: number, pageSize: number) => Method<S, E, R, T, RC, RE, RH>,\n  config: PaginationConfig<R, LD, WS>\n): UsePaginationReturnType<LD, R>;\n"))),(0,i.kt)(o.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"type ReactState<S> = [S, Dispatch<SetStateAction<S>>];\ninterface UsePaginationReturnType<LD extends any[], R> {\n  loading: boolean;\n  error: Error | undefined;\n  downloading: Progress;\n  uploading: Progress;\n  page: ReactState<number>;\n  pageSize: ReactState<number>;\n  data: LD;\n  pageCount: number | undefined;\n  total: number | undefined;\n  isLastPage: boolean;\n\n  abort: () => void;\n  send: (...args: any[]) => Promise<R>;\n  onSuccess: (handler: SuccessHandler<R>) => void;\n  onError: (handler: ErrorHandler) => void;\n  onComplete: (handler: CompleteHandler) => void;\n\n  fetching: boolean;\n  onFetchSuccess: (handler: SuccessHandler<R>) => void;\n  onFetchError: (handler: ErrorHandler) => void;\n  onFetchComplete: (handler: CompleteHandler) => void;\n\n  /**\n   * Refresh the specified page number data, this function will ignore the cache and force the request to be sent\n   * @param refreshPage refresh page number\n   */\n  refresh: (refreshPage: number) => void;\n\n  /**\n   * insert a piece of data\n   * onBefore, insert operation, onAfter all need to be executed asynchronously in sequence, because you need to wait for the view to update before executing\n   * @param item Insert item\n   * @param config insert configuration\n   */\n  insert: (item: LD[number], config?: InsertConfig) => void;\n\n  /**\n   * remove a piece of data\n   * @param index the index to remove\n   */\n  remove: (index: any) => void;\n\n  /**\n   * Reload the list from the first page and clear the cache\n   */\n  reload: () => void;\n}\n\n/**\n * React paging hook based on alova.js\n * Automatic management of paging related status, preloading of previous and previous pages, automatic maintenance of data addition/editing/removal\n *\n * @param handler method creation function\n * @param config pagination hook configuration\n * @returns {UsePaginationReturnType}\n */\nexport declare function usePagination<S, E, R, T, RC, RE, RH, LD extends any[], WS extends DependencyList>(\n  handler: (page: number, pageSize: number) => Method<S, E, R, T, RC, RE, RH>,\n  config: PaginationConfig<R, LD, WS>\n): UsePaginationReturnType<LD, R>;\n"))),(0,i.kt)(o.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface UsePaginationReturnType<LD extends any[], R> {\n  loading: Writable<boolean>;\n  error: Writable<Error | undefined>;\n  downloading: Writable<Progress>;\n  uploading: Writable<Progress>;\n  page: Writable<number>;\n  pageSize: Writable<number>;\n  data: Writable<LD>;\n  pageCount: Readable<number | undefined>;\n  total: Readable<number | undefined>;\n  isLastPage: Readonly<Readable<boolean>>;\n\n  abort: () => void;\n  send: (...args: any[]) => Promise<R>;\n  onSuccess: (handler: SuccessHandler<R>) => void;\n  onError: (handler: ErrorHandler) => void;\n  onComplete: (handler: CompleteHandler) => void;\n\n  fetching: Writable<boolean>;\n  onFetchSuccess: (handler: SuccessHandler<R>) => void;\n  onFetchError: (handler: ErrorHandler) => void;\n  onFetchComplete: (handler: CompleteHandler) => void;\n\n  /**\n   * Refresh the specified page number data, this function will ignore the cache and force the request to be sent\n   * @param refreshPage refresh page number\n   */\n  refresh: (refreshPage: number) => void;\n\n  /**\n   * insert a piece of data\n   * onBefore, insert operation, onAfter all need to be executed asynchronously in sequence, because you need to wait for the view to update before executing\n   * @param item Insert item\n   * @param config insert configuration\n   */\n  insert: (item: LD[number], config?: InsertConfig) => void;\n\n  /**\n   * remove a piece of data\n   * @param index the index to remove\n   */\n  remove: (index: any) => void;\n\n  /**\n   * Reload the list from the first page and clear the cache\n   */\n  reload: () => void;\n}\n\n/**\n * svelte paging hook based on alova.js\n * Automatic management of paging related status, preloading of previous and previous pages, automatic maintenance of data addition/editing/removal\n *\n * @param handler method creation function\n * @param config pagination hook configuration\n * @returns {UsePaginationReturnType}\n */\nexport declare function usePagination<\n  S extends Writable<any>,\n  E extends Writable<any>,\n  R,\n  T,\n  RC,\n  RE,\n  RH,\n  LD extends any[],\n  WS extends Readable<any>[]\n>(\n  handler: (page: number, pageSize: number) => Method<S, E, R, T, RC, RE, RH>,\n  config: PaginationConfig<R, LD, WS>\n): UsePaginationReturnType<LD, R>;\n")))),(0,i.kt)("h2",{id:"limit"},"limit"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The list request supports the caching function, which greatly improves the performance of the list. When you operate the list, it will internally maintain the cache generated by it. Currently, it is by modifying the ",(0,i.kt)("strong",{parentName:"li"},"name")," attribute of each Method instance. Tracking is implemented, so the Method instance passed into usePagination does not support custom names for the time being, which may affect your method management. We will also optimize it in subsequent versions."),(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"insert")," function is limited, because the data returned by usePagination is not the data returned by useWatcher, and ","[Delayed Data Update]","(../../06-next-step/08-delayed-data-update is currently unavailable. .md) function, if your new list item depends on server-side data, it is recommended to use ",(0,i.kt)("inlineCode",{parentName:"li"},"refresh")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"reload")," to re-request data, and we will support it in subsequent versions."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Cache Occupancy Mode")," and ",(0,i.kt)("strong",{parentName:"li"},"Recovery Mode")," are temporarily disabled.")))}m.isMDXComponent=!0}}]);